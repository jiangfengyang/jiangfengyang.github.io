<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>祝福</title>
    <url>/2022/08/04/zhufu/</url>
    <content><![CDATA[<p>　　第二天我起得很迟，午饭之后，去上了节物理课；第三天也照样它们也都没有什么大改变，单是难了些；课后却一律忙，都在准备着“Z神的礼拜仪式”。这是学军年终的大典，致敬尽礼，迎接福神，拜求来年一年中考试的好运气的。物理、化学、生物学，用心细细的做，理科生的草稿纸都在桌子上写得满满的，有的有还买了好几本。做完之后，横七竖八的打几个红勾在这类东西上，可就称为“做完”了，晚自习陈列起来，并且写好编号，恭请Z神们来享用；做题却只限于理科生，拜完自然仍然是下一本。科科如此，日日如此，——只要做得出力学和有机之类的——要不是是不会选理的。</p>
<span id="more"></span>

<p>　　天色愈阴暗了，下午竟下起雪来，雪花大的有梅花那么大，满天飞舞，夹着烟霭和忙碌的气色，将鲁镇乱成一团糟。我回到四叔的书房里时，瓦楞上已经雪白，房里也映得较光明，极分明的显出壁上挂着的朱拓的大“寿”字，九日老祖写的，一边的对联已经脱落，松松的卷了放在长桌上，一边的还在，道是“考试期间静心为首”。我又无聊赖的到窗下的案头去一翻，只见一堆似乎未必完全的《上帝掷色子：物理学入门基础》，一部《高级数学全解》和一部《九日语录全集》。无论Z神如何，我明天决计要走了。</p>
<p>　　况且，一直到昨天遇见她和祂的事，也就使我不能安住。</p>
<p>　　那是中午，我随着人潮直润向食堂，走出来，就在畅学园遇见祂和她；而且见其瞪着的眼睛的视线，就知道明明是向我走来的。我这回在学军所见的人们中，改变之大，可以说无过于他们的了：一个是趾高气昂的，眼睛直勾勾向上，双目又带着一股善气；一个脸上沟壑分明，额间的两根头发直直的挂着，只有那眼珠间或一轮，还可以表示她是一个活物。</p>
<p>　　我就站住，豫备她来布置作业。</p>
<p>　　“你回来了？”她先这样问。</p>
<p>　　“是的。”</p>
<p>　　“这正好。你是学军的，又是选理人，见识得多。我正要问你一件事——”她那没有精采的眼睛忽然发光了。</p>
<p>　　我万料不到她却说出这样的话来，诧异的站着。</p>
<p>　　“就是——”她走近两步，放低了声音，极秘密似的切切的说，“昨天物理课，究竟是有没有听懂的？”</p>
<p>　　我很悚然，一见她的眼盯着我的，背上也就遭了芒刺一般，比在学校里遇到不及豫防的临时考，她又偏是站在身旁否定我的时候，惶急得多了。对于听懂与否，我自己是向来毫不介意的；但在此刻，怎样回答她好呢？我在极短期的踌躇中，想，学军的人照例是巨佬的，然而她，却发现了，——或者不如说希望：希望其有，又希望其无……，人何必增添选理的人的苦恼，一为她起见，不如说有罢。</p>
<p>　　“也许有罢，——我想。”我于是吞吞吐吐的说。</p>
<p>　“那么，题都做过了？”</p>
<p>　　“啊！做题？”我很吃惊，只得支梧着，“做题—论理，就该会做。——然而也未必，……谁来管这等事……”</p>
<p>　　“那么，做过的题，全都会做了？”</p>
<p>　　“唉唉，会做不会做呢？……”这时我已知道自己也还是完全一个文科生，什么踌躇，什么计画，都挡不住三句问，我即刻胆怯起来了，便想全翻过先前的话来，“那是，……实在，我说不清……其实，究竟听懂没听懂，我也说不清。”</p>
<p>　　“你真傻，真的，”她说，</p>
<p>　　“我单知道文科生是毫无前途的，我不知道你的作业，也这同他们一般。我大晚上熬夜为你们做PPT，用不同颜色标注文字，叫我们的阿Z到讲台上做题去。祂是很听话的孩子，我的课堂堂听，祂就上去了。”</p>
<p>　　“我问祂：你这道题怎么不用E-T图像分析呀？</p>
<p>　　“‘我么？……’祂说。祂接着沉默了，她于是继续说。</p>
<p>　　“你呀。我想，这总是你不晓得用小清新的方法是了，根本没有掌握吧。‘</p>
<p>　　“阿阿，你不知道我这节课又浪费了多少分钟讲评作业了。本来有好几道题，现在又快下课了，也做不了了。</p>
<p>　　“我不信，我不信你这样聪明的理科生，真会做不出题。你后来一定是学文科的东西去了，倒推说理科作业太多写不完。</p>
<p>　　‘阿阿，你…你到自己试试看。‘祂笑着说。</p>
<p>　　“理小军，你实在不合算。”她诡秘的说。“再一强，或者索性选一个文，就好了。现在呢，你选理科不到两月，倒落了一件大罪名。你想，你将来分班去，那两个文理班主任还要争，你给了谁好呢？嘎老师只好把你锯开来，分给他们。我想，这真是……”</p>
<p>我想这回我的脸上就显出恐怖的神色来，这是换文理前未曾知道的。</p>
<p>　　……</p>
<p>　　快够半学年，我才从九日老师手里支取了历来积存期末成绩单，科科的计算着进步的名数，跑到科学馆的那头去。但不到一节课时候，我便回来，神气很舒畅，眼光也分外有神，高兴似的对九日老师说，我已经告诉她成绩了。</p>
<p>　　第二天的物理课，我做得更出力，看她和阿Z摆弄PPT，又争论起来，我便坦然地举起手来回答问题。</p>
<p>　　“你已经改了姓了，文小军！”祂慌忙大声说。</p>
<p>　　我像是受了炮烙似的缩手，脸色同时变作灰黑，也不再举手，只是失神的坐着。直到课后八分钟，她讲完课，心满意足地走开后，我才起身。这一回我的变化非常大，第二天，不但物理课不再参加，连九日课也不再听讲了。而且很胆怯，不独怕物理，怕数学，即使是生物，这似文的生物，也总惴惴的，有如九日老师甲亢时的学生们。不半周，头发也花白起来了，记性尤其坏，甚而至于常常忘却了参拜Z神。</p>
<p>　　“文小军怎么这样了？所以我说啦，倒不如那时不留她。”四婶有时当面就这样说，似乎是讥讽我。</p>
<p>　　然而我总如此，全不见有伶俐起来的希望。她于是终于打发我走了，走了，教她回到文科班那里去。但当我还在她班上的时候，不过单是这样说；等学考结束后，终于实行了。然而我是从文科生出去就成了理科生的呢，还是先成理科生然后再学文科？那我可不知道。</p>
<p>　　二零二二年某月某日夜 学军园群星楼</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/03/hello-world/</url>
    <content><![CDATA[<p>Welcome to my Blog !</p>
<span id="more"></span>]]></content>
  </entry>
  <entry>
    <title>学军历险记</title>
    <url>/2021/08/29/%E5%AD%A6%E5%86%9B%E5%8E%86%E9%99%A9%E8%AE%B0/</url>
    <content><![CDATA[<p>在学军的军训终于结束了 <del>我是忘记带防晒霜还不敢和新同学借的笨比</del></p>
<span id="more"></span>

<p>浅浅分享一下心得：</p>
<p>1.学军氛围好卷啊 ！！ 军训的晚自习就开始做重难点手册了 我开摆都摆的不心安理得</p>
<p>2.忽然有点想衢州了，，，，</p>
<p>3.zjjjjj骗人 本部没有美女呜呜呜</p>
<p>4.伙食好不习惯 一点都不辣 嘴里要淡出鸟来了</p>
<p>5.新班主任狠好狠好！！！很照顾我 </p>
<p>6.学军寝室在学校外面 晚自习结束可以出学校放风 因为是租的大学寝室所以有充电插座  ~~~ 意味着嘿嘿 ？）~~</p>
<p>偷放一张照片</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>CSP-J初赛知识点</title>
    <url>/2019/10/17/cspj/</url>
    <content><![CDATA[<h1 id="CSP-J-x2F-S-初赛知识点"><a href="#CSP-J-x2F-S-初赛知识点" class="headerlink" title="CSP-J&#x2F;S 初赛知识点"></a>CSP-J&#x2F;S 初赛知识点</h1><p>NOIP（全国青少年信息学奥林匹克竞赛）于2019年取消。取而代之的是由CCF推出的非专业级软件能力认证，也就是现在的CSP−J&#x2F;S。，我不得不备战CSP的认证。而CSP非专业级认证的第一轮（也就是NOIP初赛）常常使某些大神OIer（就是对基础知识不太了解）无缘复赛…所以今天来盘一下初赛知识点，顺带着自己也学习一下……</p>
<span id="more"></span>

<hr>
<h2 id="信息学史及基本知识"><a href="#信息学史及基本知识" class="headerlink" title="信息学史及基本知识"></a>信息学史及基本知识</h2><h3 id="一、信息学及计算机史"><a href="#一、信息学及计算机史" class="headerlink" title="一、信息学及计算机史"></a>一、信息学及计算机史</h3><ul>
<li><strong>计算机的顶级奖项</strong>：图灵奖、冯·诺依曼奖</li>
</ul>
<p>图灵奖：由ACM（美国计算机协会）设立于1966年。是“计算机界的诺贝尔奖”。</p>
<p>冯·诺依曼奖：由IE设立。</p>
<ul>
<li><strong>对信息科学做出突出贡献的大神</strong>：图灵（所以才有个奖），冯 · 诺伊曼</li>
<li><strong>中国获图灵奖的大神</strong>：姚期智（清华就有姚班，就是以他的名字命名的）</li>
<li><strong>世界第一台电子计算机</strong>：埃尼阿克（ENIACENIAC），于1946年2月14日<del>（够虐狗的）</del>在美国宾夕法尼亚大学诞生。又被叫做电子管计算机。</li>
</ul>
<h3 id="二、关于编程"><a href="#二、关于编程" class="headerlink" title="二、关于编程"></a>二、关于编程</h3><ul>
<li><strong>编程语言</strong>：</li>
</ul>
<p>分两类：面向对象和面向过程。</p>
<ul>
<li><strong>高级语言和低级语言的区别</strong>：</li>
</ul>
<p>高级语言需要编译运行，常数较大，运行速度慢。而低级语言常数极小，运行速度快。此外，高级语言更容易移植。</p>
<ul>
<li><strong>常见低级语言</strong>：</li>
</ul>
<p>汇编</p>
<ul>
<li><strong>面向对象的高级语言</strong>：</li>
</ul>
<p>C++，Java，EIFFEL，Simula 67等。</p>
<ul>
<li><strong>面向过程的高级语言</strong>：</li>
</ul>
<p>C，Fortran语言。</p>
<ul>
<li><strong>递归编程</strong>：</li>
</ul>
<p>递归是指一种通过重复将问题分解为同类的子问题而解决问题的方法。递归式方法可以被用于解决很多的计算机科学问题。简单来讲，就是“自身调用自身”（在函数中）。</p>
<ul>
<li><strong>P类&#x2F;NP类&#x2F;NPC类问题</strong>：</li>
</ul>
<p>1、P类问题：如果一个问题能找到一个在多项式时间内解决它的算法，那么这个问题就是P问题。</p>
<p>2、NP类问题：注意：NP问题<strong>不是非P类问题</strong>，而是在多项式时间内验证一个解的问题。或者，我们可以将其理解为在多项式时间内猜出一个解的问题。</p>
<p>3、NPC类问题：定义如下：如果一个问题是NP问题，而且所有的NP问题都可以约化到它。那么它就是NPC类问题。再来介绍一下关于约化的定义：如果一个问题A可以约化为问题B，含义就是这个问题A可以用问题B的解法来解决。</p>
<h3 id="三、关于计算机"><a href="#三、关于计算机" class="headerlink" title="三、关于计算机"></a>三、关于计算机</h3><p>先上张大图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194045276-1567614981.png" alt="img"></p>
<ul>
<li><p><strong>重要设备</strong>：</p>
<p>硬件组成：</p>
<ol>
<li>控制器(Control):是整个计算机的中枢神经，其功能是对程序规定的控制信息进行解释，根据其要求进行控制，调度程序、数据、地址，协调计算机各部分工作及内存与外设的访问等。</li>
<li>运算器(Datapath):运算器的功能是对数据进行各种算术运算和逻辑运算，即对数据进行加工处理。</li>
<li>存储器(Memory):存储器的功能是存储程序、数据和各种信号、命令等信息，并在需要时提供这些信息。</li>
<li>输入设备(Input system):输入设备是计算机的重要组成部分，输入设备与输出设备合称为外部设备，简称外设，输入设备的作用是将程序、原始数据、文字、字符、控制命令或现场采集的数据等信息输入到计算机。常见的输入设备有键盘、鼠标器、光电输入机、磁带机、磁盘机、光盘机等。</li>
<li>输出设备(Output system):输出设备与输入设备同样是计算机的重要组成部分，它把外算机的中间结果或最后结果、机内的各种数据符号及文字或各种控制信号等信息输出出来。微机常用的输出设备有显示终端CRT、打印机、激光印字机、绘图仪及磁带、光盘机等。</li>
</ol>
</li>
<li><p><strong>CPU及存储</strong>：</p>
</li>
</ul>
<p>CPU（中央处理器）&#x3D;运算器+控制器+寄存器</p>
<p>运算器&#x3D;算术逻辑运算单元（ALU）及浮点运算单元（FPU）</p>
<p>存储器&#x3D;内存储器+外存储器</p>
<p>BIOS是英文”Basic Input Output System”的缩略语，直译过来后中文名称就是”基本输入输出系统”。其实，它是一组固化到计算机内主板上一个ROM芯片上的程序，它保存着计算机最重要的基本输入输出的程序、系统设置信息、开机后自检程序和系统自启动程序。 其主要功能是为计算机提供最底层的、最直接的硬件设置和控制。</p>
<p>随机存储器RAM的“随机”指“随时访问”</p>
<p>所以，我们记下来以下知识点：</p>
<p><strong>断电后可以保存数据：硬盘，ROM</strong></p>
<p><strong>断电后不可以保存数据：显存（显卡内存），RAM，CPU</strong></p>
<ul>
<li><strong>计算机各存储单位及进位关系</strong>：</li>
</ul>
<p>计算机的存储单位有以下几种：</p>
<p>TB&#x2F;GB&#x2F;MB&#x2F;KB&#x2F;BTB&#x2F;GB&#x2F;MB&#x2F;KB&#x2F;B</p>
<p>他们之间的进位关系为1024（这应该是常识，没打过比赛还没玩过手机么？）</p>
<p>特殊地，1B&#x3D;8(bit)，这里的<strong>bit</strong>是二进制下的一位内存。</p>
<hr>
<h2 id="进制及进制转化"><a href="#进制及进制转化" class="headerlink" title="进制及进制转化"></a>进制及进制转化</h2><h4 id="十进制转任意进制"><a href="#十进制转任意进制" class="headerlink" title="十进制转任意进制"></a>十进制转任意进制</h4><p>将十进制转换成N进制，只需把十进制数每次除N求余数，然后把余数逆序写出来。</p>
<p>看不懂就看图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194105959-1023564667.png" alt="img"></p>
<p>这是二进制的图，其他进制就类比推一下就可以了。如果这个看不懂的话就不要参加初赛了，50块钱买点啥不好…</p>
<h4 id="任意进制转十进制"><a href="#任意进制转十进制" class="headerlink" title="任意进制转十进制"></a>任意进制转十进制</h4><p>简单说就是：按位转，第ii位的数字乘以要转换的进制的n−1次幂即可。</p>
<p>还是上图：</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194113855-1772261113.png" alt="img"></p>
<h4 id="任意进制互相转化"><a href="#任意进制互相转化" class="headerlink" title="任意进制互相转化"></a>任意进制互相转化</h4><p>这里考虑用十进制做中转，先把AA进制转十进制，再把十进制转BB进制。</p>
<h4 id="关于小数的进制转换"><a href="#关于小数的进制转换" class="headerlink" title="关于小数的进制转换"></a>关于小数的进制转换</h4><p>十进制转任意进制的小数不进行除法运算，而进行乘法运算后取整，取整后从前向后排列。</p>
<p>任意进制转十进制的小数只需要乘上负指数，最后算出来即可。</p>
<h4 id="各进制的字母表达"><a href="#各进制的字母表达" class="headerlink" title="各进制的字母表达"></a>各进制的字母表达</h4><p>H(Hexadecimal)——16进制</p>
<p>D(Decimal)——10进制</p>
<p>O(Octonary)——8进制</p>
<p>B(Binary)——2进制</p>
<h4 id="二进制的相关知识"><a href="#二进制的相关知识" class="headerlink" title="二进制的相关知识"></a>二进制的相关知识</h4><p>二进制是计算机进行计算所使用的工具，自然也是非常常考的要点。二进制的相关知识有许多，甚至算法中的位运算也是二进制的相关内容，但为了过第一轮初赛，我们只介绍一些理论知识。关于位运算的相关知识请有兴趣的同学自己学习。</p>
<ul>
<li><strong>1、原码</strong></li>
</ul>
<p>顾名思义，原码就是十进制数直接转换成二进制之后直接形成的二进制编码。</p>
<ul>
<li><strong>2、补码</strong></li>
</ul>
<p>正数的补码是本身，负数的补码是其<strong>反码加一</strong>。</p>
<ul>
<li><strong>3、反码</strong></li>
</ul>
<p>顾名思义：正数的反码是本身，负数的反码是其除符号位之外的所有位按位取反的结果。</p>
<h4 id="附：ASCII码"><a href="#附：ASCII码" class="headerlink" title="附：ASCII码"></a>附：ASCII码</h4><p>ASCII码的正规名称是：<strong>美国信息交换标准代码</strong>，是基于拉丁字母的一套电脑编码系统。是最通用的信息交换标准。一共定义了<strong>128</strong>个字符。</p>
<p>这里不赋ASCII码的转换表。只给出几种比较常用的转换：</p>
<p>字符0→48</p>
<p>大写字母A→65</p>
<p>小写字母a→97</p>
<p>空格→32</p>
<p>换行→13</p>
<hr>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><p>位运算不仅在初赛中是一个知识点分类，在复赛（即真正的程序设计与运用）的时候也有很大的一个应用。而且，位运算的相关知识是计算机运算的灵魂，更是每个程序猿应该理解的一种基本操作。</p>
<p>关于位运算的相关知识，本蒟蒻在另一篇专门的博客中详细的讲解。</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11384756.html">常用的位运算技巧</a></p>
<p>为了应对初赛的笔试题，建议读者在阅读完这篇博客之后至少应该掌握：<strong>各种位运算的运算法则以及位运算优先级</strong>。</p>
<h2 id="另外，对于位运算的优先级，本蒟蒻在后面的逻辑运算部分还会有详细的解析。"><a href="#另外，对于位运算的优先级，本蒟蒻在后面的逻辑运算部分还会有详细的解析。" class="headerlink" title="另外，对于位运算的优先级，本蒟蒻在后面的逻辑运算部分还会有详细的解析。"></a>另外，对于位运算的优先级，本蒟蒻在后面的逻辑运算部分还会有详细的解析。</h2><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h4 id="逻辑运算-1"><a href="#逻辑运算-1" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><p>逻辑运算一共有三种，每种都有两种写法：</p>
<p><strong>逻辑非</strong>：！或 ┐</p>
<p><strong>逻辑与</strong>：&amp;&amp; 或 ∧</p>
<p><strong>逻辑或</strong>：|| 或 ∨</p>
<h4 id="逻辑运算的优先级"><a href="#逻辑运算的优先级" class="headerlink" title="逻辑运算的优先级"></a>逻辑运算的优先级</h4><p>非&gt;&gt;与&gt;&gt;或</p>
<h4 id="位运算-逻辑运算的优先级"><a href="#位运算-逻辑运算的优先级" class="headerlink" title="位运算+逻辑运算的优先级"></a>位运算+逻辑运算的优先级</h4><p><strong>逻辑非（！，┐）&#x3D;按位反（~）&gt;位移运算（&lt;&lt;,&gt;&gt;）&gt;不等号（&gt;&#x3D;,&lt;&#x3D;）&gt;等号（&#x3D;&#x3D;,!&#x3D;）&gt;按位与（&amp;）&gt;按位异或（^）&gt;按位或（|）&gt;逻辑与（&amp;&amp;，∧）&gt;逻辑或（||，∨）</strong></p>
<h4 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h4><p>由逻辑运算复合而成，只有两种结果：true和falsee，在C&#x2F;C++中，返回的值以0表示假，以1表示真。</p>
<h4 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h4><p>条件表达式的基本形式如下：</p>
<p>&lt;表达式1&gt;？&lt;表达式2&gt;：&lt;表达式3&gt;</p>
<p>其表达意义是：如果表达式1成立，则执行表达式2，否则执行表达式3。其实也等价于if−elseif−else条件语句。例如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#define Min(a,b) a&lt;b?a:b</span><br></pre></td></tr></table></figure>

<p><strong>注意：</strong>如果条件表达式有多个进行复合，那么在执行的时候需要从由往左依次判断最后得出一个结果。即：<strong>右结合性</strong>。</p>
<p>比如：</p>
<p>&lt;表达式1&gt;？&lt;表达式2&gt;：&lt;表达式3&gt;？&lt;表达式4&gt;：&lt;表达式5&gt;</p>
<p>那么，在执行的时候是从3开始判断是否为真，然后执行某一个表达式，依次向上回溯。</p>
<hr>
<h2 id="图论理论知识"><a href="#图论理论知识" class="headerlink" title="图论理论知识"></a>图论理论知识</h2><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul>
<li><strong>完全图</strong>：任意两点都有边相连，我们很容易推出来，一张完全图的边数为（nn为节点个数）</li>
</ul>
<p>n×(n−1)2</p>
<ul>
<li><strong>连通图</strong>：顾名思义，连通图就是连通的图，即任意两点都能<strong>直接或间接</strong>到达，这就区别于完全图必须直接用边到达的定义。</li>
<li><strong>树</strong>：emm…直观来讲，就是一张长得像树的图。定义是任意两点之间的简单路径有且只有一条。树是一棵连通且无环的图。它的边数是n−1。</li>
</ul>
<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><p>二叉树有不同的遍历方式，一般来讲，我们将其分成三类：先序遍历（也叫先根遍历）、中序遍历（中根遍历）以及后序遍历（后根遍历）。</p>
<ul>
<li><strong>先序遍历</strong>：遍历方式如下：根—左儿子—右儿子</li>
<li><strong>中序遍历</strong>：遍历方式如下：左儿子—根—右儿子</li>
<li><strong>后序遍历</strong>：遍历方式如下：左儿子—右儿子—根</li>
</ul>
<p>我们用一张图来理解一下这几种遍历方式。</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194132352-921608749.png" alt="img"></p>
<p>这张图的先序遍历：1245367</p>
<p>中序遍历：4251637</p>
<p>后序遍历：4526731</p>
<ul>
<li><p><strong>一个推论</strong>：</p>
<p>先序遍历+中序遍历&#x3D;一棵确定的二叉树</p>
<p>后序遍历+中序遍历&#x3D;一棵确定的二叉树</p>
<p>先序遍历+后序遍历&#x3D;啥也不是</p>
</li>
</ul>
<h4 id="特殊二叉树及其性质"><a href="#特殊二叉树及其性质" class="headerlink" title="特殊二叉树及其性质"></a>特殊二叉树及其性质</h4><ul>
<li><strong>完全二叉树</strong>：只有最后一层不是满的，且最后一层的所有节点均集中在左侧。</li>
</ul>
<p>图例如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194142510-126705239.png" alt="img"></p>
<ul>
<li><strong>满二叉树</strong>：节点个数已满。</li>
</ul>
<p>图例如下：</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194150593-2109496461.png" alt="img"></p>
<ul>
<li><strong>特殊二叉树的性质</strong>：</li>
</ul>
<p>1、对于一棵完全二叉树来讲，它的叶子节点为n，则节点总数为2×n−1。此结论可逆。</p>
<p>2、对于一棵满二叉树来讲，它的层数（深度）为k，则它的节点总数为2k−1。此结论可逆。</p>
<h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><p>本蒟蒻有一篇专门讲拓扑排序的讲解：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11331916.html">拓扑排序详解</a></p>
<hr>
<h2 id="简单数据结构基本理论"><a href="#简单数据结构基本理论" class="headerlink" title="简单数据结构基本理论"></a>简单数据结构基本理论</h2><h4 id="1、栈"><a href="#1、栈" class="headerlink" title="1、栈"></a>1、栈</h4><p>想象一个桶，你从上面往里扔砖，然后你想把某一块砖拿出来，你需要先拿出来你后扔进去的砖。这就是栈。栈的基本原则是：后进先出</p>
<p>来一发图示？</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194156752-1724424437.png" alt="img"></p>
<h4 id="附：前、中、后缀表达式"><a href="#附：前、中、后缀表达式" class="headerlink" title="附：前、中、后缀表达式"></a>附：前、中、后缀表达式</h4><p>一篇专门的博客：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11615499.html">浅谈前、中、后缀表达式</a></p>
<h4 id="2、队列"><a href="#2、队列" class="headerlink" title="2、队列"></a>2、队列</h4><p>想象你在排队买票，这个队伍中的人都非常有素质，都自觉排队而且不会提前离开队伍。这样就只能从队首买完票再离开，从队尾进入队伍。队列的基本原则是：先进先出。</p>
<p>再来一发图示：</p>
<p><img src="https://img2018.cnblogs.com/blog/1738131/201909/1738131-20190920194202009-539251419.png" alt="img"></p>
<h4 id="3、链表"><a href="#3、链表" class="headerlink" title="3、链表"></a>3、链表</h4><p>链表分两种：单向链表和双向链表。关于链表，我有一篇专门讲解的博客。有兴趣的读者请戳：</p>
<p><a href="https://www.cnblogs.com/fusiwei/p/11387165.html">链表详解</a></p>
<h4 id="4、字符串"><a href="#4、字符串" class="headerlink" title="4、字符串"></a>4、字符串</h4><p>字符串子串的概念：字符串是一串字符<del>（废话）</del>，它的子串被定义为：字符串中<strong>任意个连续的字符组成的子序列</strong>。</p>
<p>字符串子串个数的计算公式：</p>
<p>n×(n+1)2+1</p>
<p>（就是字符串长度等差数列）</p>
<p>如果是非空子串，就把那个一减去即可（子串个数的公式加一就是考虑空子串的情况）。</p>
<hr>
<h2 id="时空复杂度的计算"><a href="#时空复杂度的计算" class="headerlink" title="时空复杂度的计算"></a>时空复杂度的计算</h2><ul>
<li><strong>时间复杂度</strong>：渐进时间复杂度用符号OO 表示。一个程序的语句执行次数可以用一个代数式表示，那么我们取这个代数式的最高次项且忽略此项系数作为时间复杂度。如果一个程序的语句执行次数为 n3，那么这个程序的渐进时间复杂度为O(n3)。</li>
<li><strong>计算非递归程序的时间复杂度</strong>：简单粗暴，数循环。</li>
<li><strong>常数</strong>：常数即为我们忽略掉的OO中最高次项的系数与低次项所带来的时间消耗。</li>
<li><strong>空间复杂度</strong>：类比时间复杂度。看开空间开了多大。</li>
<li><strong>计算空间占用量</strong>：根据我们以上说过的计算机存储单位的知识：一个intint占用的内存是4B4B，所以我们把开的intint乘上4，再除以1024就是KBKB，同理，再除10241024就是MBMB。</li>
</ul>
<p>公式：nn为元素个数，MM为最终答案（以MBMB为单位）</p>
<p>M&#x3D;1024×1024M</p>
<p>PS:一般来讲，比赛中所给的256MB内存可以开6×107个int</p>
<p>类型的变量。另外，大数组必须开全局变量。如果扔在主函数里极容易爆栈。</p>
<hr>
<h2 id="数学、逻辑学及运筹学知识"><a href="#数学、逻辑学及运筹学知识" class="headerlink" title="数学、逻辑学及运筹学知识"></a>数学、逻辑学及运筹学知识</h2><ul>
<li><strong>排列组合</strong>：排列组合是每年必考知识点。但是这是一个比较大的课题。不仅是高二数学选修重点，也是数学编程的一个重要分支。关于排列组合及相关知识，我有一个专门讲解排列组合的博客，欢迎读者翻阅：</li>
</ul>
<p><a href="https://www.cnblogs.com/fusiwei/p/11358009.html">浅谈排列组合</a></p>
]]></content>
      <tags>
        <tag>初赛</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>博弈论</title>
    <url>/2019/10/17/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="博弈论"><a href="#博弈论" class="headerlink" title="博弈论"></a>博弈论</h1><p>一些简单的定义：</p>
<p>必胜点（N点）：走到必胜点的玩家一定胜利。<br>必败点（P点）：走到必败点的玩家一定失败。</p>
<span id="more"></span>

<blockquote>
<p>定理1.所有游戏终结的点都是必败点。<br>定理2.所有一步<strong>能</strong>走到必败点的就是必胜点。因为对手将面临必败点。<br>定理3.通过一步操作<strong>只能</strong>到必胜点的就是必败点。因为对手将获得必胜点。  </p>
</blockquote>
<h2 id="取石子游戏"><a href="#取石子游戏" class="headerlink" title="取石子游戏"></a>取石子游戏</h2><p>有两堆石子和两个玩家。<br>每回合，玩家可以选择从<strong>某一堆</strong>取走一个石子，或者从<strong>两堆</strong>中都取走一个石子。  </p>
<p>最后无法操作的玩家失败。</p>
<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>以**(A,B)<strong>表示当前的状态：第一堆有</strong>A<strong>个石子，第二堆有</strong>B<strong>个石子。<br>由于这个游戏没有和局，所以</strong>某个状态不是必败点就是必胜点**。</p>
<p>首先考虑<code>终结点</code>：两堆石子都空了，面对这个状态的玩家必败。<br>于是有了第一个必败点：**(0,0)**。</p>
<blockquote>
<p>定理2.所有一步能走到必败点的就是必胜点。因为对手将面临必败点。  </p>
</blockquote>
<p>由于**(0,1)<strong>和</strong>(1,0)<strong>能走到</strong>(0,0)**，因此它们是必胜点。</p>
<blockquote>
<p>定理3.通过一步操作<strong>只能</strong>到必胜点的就是必败点。因为对手将获得必胜点。  </p>
</blockquote>
<p>考虑**(0,1)<strong>，显然</strong>(0,2)<strong>只能走到</strong>(0,1)<strong>，所以</strong>(0,2)<strong>是必败点。由于</strong>(0,3)<strong>能走到</strong>(0,2)<strong>让对手必败，所以</strong>(0,3)<strong>是必胜点。<br>以此类推，我们得到结论：</strong>(0,2k)<strong>是必败点，</strong>(0,2k+1)**是必胜点。</p>
<p>如何让对手面临**(0,2k)<strong>呢？显然，当目前局面是</strong>(1,2k+1)<strong>时，可以两堆各取一个石子，所以</strong>(1,2k+1)<strong>是必胜点。<br>类似地，</strong>(1,2k)**是必胜点，因为：  </p>
<ol>
<li>先手不取<strong>1</strong>那一堆石子。则后手得到**(1,2k-1)**必胜。因此不会这样选。</li>
<li>先手取走<strong>1</strong>那一堆石子。则后手得到**(0,2k)**局面必败。先手胜。</li>
<li>两堆石子都取。则后手得到**(0,2k-1)**必胜，因此不会这样选。</li>
</ol>
<p>因此我们得到结论：**(1,*)**是必胜点。</p>
<p>由于**(1,<em>)<strong>必胜，且</strong>(2,2)<strong>只能走到</strong>(1,</em>)<strong>，所以</strong>(2,2)<strong>必败。<br>故</strong>(2,3)<strong>和</strong>(3,3)<strong>是必胜点。由于</strong>(2,4)<strong>是必败点，所以</strong>(3,4)**是必胜点。</p>
<p>稍微推理一番就得知：  </p>
<blockquote>
<p><code>(偶数,偶数)</code>是必败点。<br><code>(奇数,偶数)</code>是必胜点。<br><code>(偶数,奇数)</code>是必胜点。<br><code>(奇数,奇数)</code>是必胜点。  </p>
</blockquote>
<p>历经艰险，总算把事情推完了。博弈论真是迷人……</p>
<h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><p>Alice和Bob正在玩一个游戏，Alice先手。</p>
<p>他们面前有三堆石子。Alice和Bob轮流操作，每次从某堆中取走任意张。<br>没石子可取的玩家失败。</p>
<p>那么这个博弈如何做？  </p>
<p>抱歉，我也不会证，只知道结论，如果要证，请找<a href="http://link-arthur.github.io/">Link神</a>。</p>
<p>像之前那样以(a,b,c)表示状态。结论是(⊕表示异或)：  </p>
<ol>
<li>当且仅当a ⊕  b ⊕ c &#x3D; 0时，(a,b,c)是必败点。</li>
<li>否则就是必胜点。</li>
</ol>
<p>结论可以推广：<br>若有n堆石子，则当且仅当a ⊕ b  ⊕ c ⊕ d… &#x3D; 0**时，此点是必败点。</p>
<h2 id="SG函数"><a href="#SG函数" class="headerlink" title="SG函数"></a>SG函数</h2><p>留坑待补</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>三分查找</title>
    <url>/2019/10/16/%E4%B8%89%E5%88%86%E6%9F%A5%E6%89%BE/</url>
    <content><![CDATA[<h2 id="三分查找"><a href="#三分查找" class="headerlink" title="三分查找"></a>三分查找</h2><blockquote>
<p>三分查找用于求单峰函数的极值。<br>速度快，但是结果并非准确值。  </p>
</blockquote>
<span id="more"></span>

<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>首先，在函数上标<strong>4个</strong>点：x&#x3D;le,rt,mid,mmid。其中mmid是mid与rt的中点。  </p>
<p>现在的任务是通过<code>迭代</code>缩小范围：  </p>
<blockquote>
<ol>
<li>如果f(mid)&gt;f(mmid)，则mmid一定在峰的右边。    </li>
<li>如果f(mid)&lt;f(mmid)，则mid一定在峰的左边。</li>
</ol>
</blockquote>
<p>证明：</p>
<ol>
<li>我们假设存在f(mid)&gt;f(mmid)且mmid在峰的左边。<br>由于f(x)在峰的左边单调递增，且f(mid)&gt;f(mmid)，所以mid在mmid的<strong>右边</strong>。<br>然而mmid &#x3D; \frac{mid+rt}{2}，显然mid在mmid<strong>左边</strong>。矛盾。  <br></li>
<li>我们假设存在f(mid)&lt;f(mmid)且mid在峰的右边。<br>由于f(x)在峰的右边单调递减，且f(mid)&lt;f(mmid)，所以mid在mmid的<strong>右边</strong>。<br>然而mmid &#x3D; \frac{mid+rt}{2}，显然mid在mmid<strong>左边</strong>。矛盾。</li>
</ol>
<h2 id="食用姿势"><a href="#食用姿势" class="headerlink" title="食用姿势"></a>食用姿势</h2><p>首先我们要证明，需要三分的函数是个<strong>单峰函数</strong>。<br>然后就可以写三分了。</p>
<p><strong>如何控制精度？</strong><br>两种办法。一种是<code>控制迭代次数</code>，一种是<code>直接控制精度</code>。</p>
<p><code>控制迭代次数</code>：设一个 lambda 值，迭代了这么多次之后就退出。<br><code>直接控制精度</code>：设一个精度限制 eps ，如果 rt-le &lt; eps 就退出。  </p>
<p>具体用哪种方式<strong>由题目决定</strong>。<br>一般来说，如果题目要求控制<em>相对精度</em>，控制迭代次数比较好；如果题目要求控制<em>绝对精度</em>，直接去控制精确到小数点后多少位比较好。  </p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>近似算法</title>
    <url>/2019/10/16/%E8%BF%91%E4%BC%BC%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="近似算法"><a href="#近似算法" class="headerlink" title="近似算法"></a>近似算法</h1><blockquote>
<p>一万年没更新博客了……毕竟我这么弱。<br>来玩一玩模拟退火算法和遗传算法。</p>
</blockquote>
<p>我们的问题是，给定一个乱七八糟的函数，求它在某个区域内的最大值。</p>
<span id="more"></span>

<h2 id="模拟退火算法"><a href="#模拟退火算法" class="headerlink" title="模拟退火算法"></a>模拟退火算法</h2><h3 id="爬山"><a href="#爬山" class="headerlink" title="爬山"></a>爬山</h3><p>爬山算法是纯粹的贪心算法。给定一个起始点，我们能爬到一个极大值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">    if(f(x+0.001) - f(x-0.001) &gt; eps)  x+=0.001;         </span><br><span class="line">    //如果向右走有利，则向右走</span><br><span class="line">    else if(f(x+0.001) - f(x-0.001) &lt; -eps) x+=0.001;</span><br><span class="line">    //如果向左走有利，则向左走</span><br><span class="line"></span><br><span class="line">    else goto finish;       //已经爬到极大值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>爬山的缺陷在于，它会陷入局部最优解，而难以爬到全局最优解。例如下图。 <img src="http://i1.piimg.com/567571/42e0f0a7fea0b290.png" alt="爬山"></p>
<p>我们把上面的<code>x+0.001</code>之类的操作称作“移动”。</p>
<h3 id="经典模拟退火"><a href="#经典模拟退火" class="headerlink" title="经典模拟退火"></a>经典模拟退火</h3><p>模拟退火的思想在于，如果一个移动会<strong>使答案变得更优</strong>，我们就接受这个移动；否则我们以<strong>一定的概率</strong>接受这个移动。</p>
<p>听起来很玄学。根据物理的那套理论，我们定义两个东西：<br>- 温度(T)(T)。它随着时间推移而逐渐降低。<br>- 增量(E)(E)。它描述一次移动获得的好处。从xx移动到x′x′的增量定义为f(x′)−f(x)f(x′)−f(x)，增量越大，往x′x′移动的优势越大。</p>
<p>在模拟退火中，如果增量大于00，则直接接受这次移动；否则按下面的概率接受移动：</p>
<p>P&#x3D;exp(ET)P&#x3D;exp⁡(ET)</p>
<p>听起来十分的玄学。然而它竟然可以得出精度比较好的解。伪代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">T=100.0;               //初始温度</span><br><span class="line"></span><br><span class="line">for(int i=0;i&lt;100;i++)      //控制迭代次数</span><br><span class="line">&#123;</span><br><span class="line">    tar=getPos();           //在x的周围选一个点</span><br><span class="line">    E=f(tar)-f(x);</span><br><span class="line"></span><br><span class="line">    if(E &gt; eps) x=tar;      //直接移动</span><br><span class="line">    else if(exp(E/T) &gt; random(0,1)) x=tar;     //接受移动</span><br><span class="line"></span><br><span class="line">    T=T*0.99;               //降温</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="遗传算法"><a href="#遗传算法" class="headerlink" title="遗传算法"></a>遗传算法</h2><p>不妨假设有一大群兔子，它们均匀地分布在各种地方。<br>由于一些黑恶势力的影响，每年只有位置最高的那100只兔子能活下来。</p>
<p>位置最高的那些兔子们繁衍生息，它们的后代有些比它们站得高，于是这些后代活了下来；其他后代被黑恶势力搞死了。每年都只有站得最高的100只兔子能活下来。</p>
<p>在无尽的岁月后，这100只兔子想必都站在了世界上最高的山峰。</p>
<p>这个算法听起来比模拟退火靠谱。现在它的实现过程如下：</p>
<ol>
<li>先随机产生100个点，均匀地分布在所求区间上。</li>
<li>取每两个点的中位数，这样我们共获得了10000个点。</li>
<li>取出最高的100个点，然后开始新一轮迭代。</li>
</ol>
<p>但是这会引发一个问题。例如下图：</p>
<p><img src="http://i1.piimg.com/567571/0d87fe3e1bcc6437.png" alt="问题"></p>
<p>这样的话，无论我们迭代多少次，总是找不到最高点（因为是取中位数）。这搞屁。</p>
<p>所以我们引入<strong>变异</strong>。每个数都有二进制表示，我们产生一个数之后，对它进行变异操作：二进制的每一位都以pp的概率翻转。</p>
<p>这样的话，由于变异的存在，迭代若干次之后，最高点是找得到的。</p>
<p>那么问题来了。<strong>pp到底取多少？</strong></p>
<p>恭喜您打开了黑暗世界的大门——玄学调参数。由于我们很难给出一个很妙的pp，遗传算法变得比模拟退火还不靠谱。</p>
<p>如何玄学调参数呢？我们造一些区间比较小的数据，暴力求出答案，然后根据这些数据来调整pp。猜很多个pp的值，看哪个最好。我们只需要考虑p&lt;0.5p&lt;0.5的情况，因为<code>以p的概率翻转</code>，和<code>以p的概率不翻转</code>是本质相同的。</p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>排序模板</title>
    <url>/2019/10/13/%E6%8E%92%E5%BA%8F%E6%A8%A1%E6%9D%BF/</url>
    <content><![CDATA[<p>​	给大家推荐一套排序的模板，综合了冒泡排序，选择排序，插入排序，快速排序，希尔排序，归并排序，堆排序，基数排序。还是比较实用的</p>
<span id="more"></span>

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> len = <span class="number">20</span>;<span class="comment">//待排序数组元素的个数，下标从1开始</span></span><br><span class="line"><span class="comment">//1、冒泡排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Bubble_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">bool</span> flag;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len<span class="number">-1</span>;++i)&#123;</span><br><span class="line">        flag=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=len-i;++j)</span><br><span class="line">            <span class="keyword">if</span>(s[j]&gt;s[j+<span class="number">1</span>])&#123;flag=<span class="literal">true</span>;<span class="built_in">swap</span>(s[j],s[j+<span class="number">1</span>]);&#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag)<span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2、选择排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Select_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;len;++i)&#123;</span><br><span class="line">        k=i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i+<span class="number">1</span>;j&lt;=len;++j)</span><br><span class="line">            <span class="keyword">if</span>(s[k]&gt;s[j])k=j;</span><br><span class="line">        <span class="keyword">if</span>(k!=i)<span class="built_in">swap</span>(s[i],s[k]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//3、插入排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Insert_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp,j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=len;++i)&#123;</span><br><span class="line">        tmp=s[i];</span><br><span class="line">        <span class="keyword">for</span>(j=i<span class="number">-1</span>;j&gt;<span class="number">0</span>&amp;&amp;tmp&lt;s[j];--j);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=i;k&gt;j+<span class="number">1</span>;--k)s[k]=s[k<span class="number">-1</span>];</span><br><span class="line">        s[j+<span class="number">1</span>]=tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//4、快速排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Quick_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=s[low];<span class="comment">//首元素是枢轴</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)&#123;<span class="comment">//待排序序列长度大于1</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;tmp&lt;=s[high])--high;<span class="comment">//大于枢轴的元素依旧在右边</span></span><br><span class="line">        s[low]=s[high];<span class="comment">//将小于枢轴的元素放左边</span></span><br><span class="line">        <span class="keyword">while</span>(low&lt;high&amp;&amp;tmp&gt;=s[low])++low;<span class="comment">//小于枢轴的元素依旧在左边</span></span><br><span class="line">        s[high]=s[low];<span class="comment">//将大于枢轴的元素放右边</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[low]=tmp;<span class="comment">//枢轴记录到位</span></span><br><span class="line">    <span class="keyword">return</span> low;<span class="comment">//返回枢轴的位置，表示该位置已经排好序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Qsort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> key=<span class="built_in">Quick_sort</span>(s,low,high); <span class="comment">// 第key个元素已经排好序，继续两边搜索排序</span></span><br><span class="line">        <span class="built_in">Qsort</span>(s,low,key<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">Qsort</span>(s,key+<span class="number">1</span>,high);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//5、希尔排序(采用直接插入)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Shell_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp,j;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> step=len/<span class="number">2</span>;step&gt;<span class="number">0</span>;step/=<span class="number">2</span>)&#123;<span class="comment">//设置步长</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=step;i&lt;=len;++i)&#123;</span><br><span class="line">            tmp=s[i];</span><br><span class="line">            <span class="keyword">for</span>(j=i-step;j&gt;<span class="number">0</span>&amp;&amp;tmp&lt;s[j];j-=step);</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> k=i;k&gt;j+step;k-=step)s[k]=s[k-step];</span><br><span class="line">            s[j+step]=tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6、归并排序</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> t[],<span class="type">int</span> low,<span class="type">int</span> mid,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i=low,j=mid+<span class="number">1</span>,k=low;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid&amp;&amp;j&lt;=high)&#123;</span><br><span class="line">        <span class="keyword">if</span>(s[i]&lt;=s[j])t[k++]=s[i++];</span><br><span class="line">        <span class="keyword">else</span> t[k++]=s[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;=mid)t[k++]=s[i++];</span><br><span class="line">    <span class="keyword">while</span>(j&lt;=high)t[k++]=s[j++];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=low;i&lt;=high;++i)s[i]=t[i];<span class="comment">//将区间[low,high]拷贝到原来数组s对应的位置，表示该区间元素已排好序</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Merge_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> t[],<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(low&lt;high)&#123;</span><br><span class="line">        <span class="type">int</span> mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        <span class="built_in">Merge_sort</span>(s,t,low,mid);<span class="comment">//递归分成左部分</span></span><br><span class="line">        <span class="built_in">Merge_sort</span>(s,t,mid+<span class="number">1</span>,high);<span class="comment">//递归分成右部分</span></span><br><span class="line">        <span class="built_in">Merge</span>(s,t,low,mid,high);<span class="comment">//将两部分归并</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//7、堆排序(大根堆实现升序排序)</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heap_Adjust</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> cur,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> tmp=s[cur];<span class="comment">//先取出当前元素cur</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*cur;j&lt;=len;j*=<span class="number">2</span>)&#123;<span class="comment">//向下筛选</span></span><br><span class="line">        <span class="keyword">if</span>(j&lt;len&amp;&amp;s[j]&lt;s[j+<span class="number">1</span>])++j;</span><br><span class="line">        <span class="keyword">if</span>(tmp&gt;=s[j])<span class="keyword">break</span>;</span><br><span class="line">        s[cur]=s[j];cur=j;<span class="comment">//将子节点j值赋给父节点cur（不用进行交换）</span></span><br><span class="line">    &#125;</span><br><span class="line">    s[cur]=tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Heap_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="comment">//1、构建大根堆</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len/<span class="number">2</span>;i&gt;<span class="number">0</span>;--i)<span class="built_in">Heap_Adjust</span>(s,i,len);</span><br><span class="line">    <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">1</span>;--i)&#123;</span><br><span class="line">        <span class="built_in">swap</span>(s[i],s[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">Heap_Adjust</span>(s,<span class="number">1</span>,i<span class="number">-1</span>);<span class="comment">//将[1,i-1]重新调整为大根堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//8、基数排序</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Max_bit</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;<span class="comment">//获取数组中最大值的位数</span></span><br><span class="line">    <span class="type">int</span> dit=<span class="number">1</span>,p=<span class="number">10</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        <span class="keyword">while</span>(s[i]&gt;=p)&#123;++dit;p*=<span class="number">10</span>;&#125;</span><br><span class="line">    <span class="keyword">return</span> dit;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Radix_sort</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> exp=<span class="number">1</span>,dit=<span class="built_in">Max_bit</span>(s,len),*cnt=<span class="keyword">new</span> <span class="type">int</span>[<span class="number">10</span>],*tmp=<span class="keyword">new</span> <span class="type">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=dit;++j)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;++i)cnt[i]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)cnt[s[i]/exp%<span class="number">10</span>]++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;++i)cnt[i]+=cnt[i<span class="number">-1</span>];<span class="comment">//叠加元素个数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len;i&gt;<span class="number">0</span>;--i)tmp[cnt[s[i]/exp%<span class="number">10</span>]--]=s[i];<span class="comment">//将桶中元素倒出来</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)s[i]=tmp[i];<span class="comment">//将倒出来的元素依次放到原数组中去</span></span><br><span class="line">        exp*=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[]cnt;<span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[]tmp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//打印数组元素值</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">print</span><span class="params">(<span class="type">int</span> s[],<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">        cout&lt;&lt;s[i]&lt;&lt;(i==len?<span class="string">&quot;\n&quot;</span>:<span class="string">&quot; &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> *s=<span class="keyword">new</span> <span class="type">int</span>[len+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> *t=<span class="keyword">new</span> <span class="type">int</span>[len+<span class="number">1</span>];<span class="comment">//t为辅助数组</span></span><br><span class="line">    <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)s[i]=<span class="built_in">rand</span>();</span><br><span class="line">    <span class="built_in">print</span>(s,len);<span class="comment">//打印原数组</span></span><br><span class="line">    <span class="comment">/*1、冒泡排序</span></span><br><span class="line"><span class="comment">    Bubble_sort(s,len);*/</span></span><br><span class="line">    <span class="comment">/*2、选择排序</span></span><br><span class="line"><span class="comment">    Select_sort(s,len);*/</span></span><br><span class="line">    <span class="comment">/*3、插入排序</span></span><br><span class="line"><span class="comment">    Insert_sort(s,len);*/</span></span><br><span class="line">    <span class="comment">/*4、快速排序</span></span><br><span class="line"><span class="comment">    Qsort(s,1,len);*/</span></span><br><span class="line">    <span class="comment">/*5、希尔排序</span></span><br><span class="line"><span class="comment">    Shell_sort(s,len);*/</span></span><br><span class="line">    <span class="comment">/*6、归并排序</span></span><br><span class="line"><span class="comment">    Merge_sort(s,t,1,len);*/</span></span><br><span class="line">    <span class="comment">/*7、堆排序</span></span><br><span class="line"><span class="comment">    Heap_sort(s,len);*/</span></span><br><span class="line">    <span class="comment">/*8、基数排序</span></span><br><span class="line"><span class="comment">    Radix_sort(s,len);*/</span></span><br><span class="line">    <span class="built_in">print</span>(s,len);<span class="comment">//打印排序后的数组元素</span></span><br><span class="line">    <span class="keyword">delete</span>[]s;<span class="comment">//释放内存</span></span><br><span class="line">    <span class="keyword">delete</span>[]t;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>红星照耀中国读后感</title>
    <url>/2019/10/13/%E7%BA%A2%E6%98%9F%E7%85%A7%E8%80%80%E4%B8%AD%E5%9B%BD%E8%AF%BB%E5%90%8E%E6%84%9F/</url>
    <content><![CDATA[<p>​	《红星照耀中国》又称《西行漫记》，是著名记者埃德加-斯诺的不朽名著，作者真实记录了自1936年6月至10月在中国西北革命根据地的所见所闻，向全世界真实地报道了中国共产党和中国工农红军以及许多红军领袖、将领的情况。整本书以斯诺的第一视角,生动丰富地描述了红色根据地大大小小的人物与事件,他通过搜集长征的第一手资料,与革命领导人进行谈话,运用文字的力量将这段波澜壮阔、激情燃烧的岁月鲜活地呈现在我们眼前。</p>
<span id="more"></span>

<p>​	这本书有很多故事感人至深，至今印象深刻。其中有这样一个故事：官帽山上的300多名红军被敌军重重围困。团长许光达突然看见有一条长长的藤萝，马上带领红军战士用藤萝顺利下官帽山。红军战士用智慧和勇敢突围了。还有一个故事：夏明翰在1921年成为共产党员，后来，由于叛徒的出卖，夏明翰不幸被捕。夏明翰写下了那首著名的起义诗：砍头不要紧，只要主义真。杀了夏明翰，还有后来人！从这两个故事中让我知道了红军战士们以他们的生命和鲜血，谱写了一曲曲胜利的凯歌，为中国人民事业立下了不朽功绩。</p>
<p>​	在《红色照耀中国》中，作者用铁的事实向世界宣告：中国共产党及其领导的革命事业犹如一颗善良的红星不仅照耀着中国的西北，而且必将照耀全中国，照耀全世界。同时，作者在书中用风趣朴实的语言描绘了中国共产党人和红军战士坚韧不拔、英勇卓绝的伟大斗争，以及红军的领袖人物的伟大而平凡的精神风貌。</p>
<p>​	读这本书，我通过领导人们的自述，了解了毛泽东、朱德、彭德怀等中国共产党的领导人和红军将领的生平经历，我就像亲眼看到了红军二万五千里长征中付出的艰辛。我知道了红军的生活，我还知道了小小年纪就参加革命的“红小鬼”，我“亲身经历”了那次的西安事变……《红星照耀中国》真切地让我们再次回到了那段激情燃烧，烽火连天的峥嵘岁月，深刻地感受到中国共产党进行革命的艰难历程。</p>
<p>​	我们要珍惜现在来之不易的美好生活，在生活，学习中百折不挠，努力拼搏，把红军精神发扬光大，让红军精神代代相传。让我们铭记那段历史吧，珍惜今天所拥有的，跟这位美国人一样深爱着这片红色土地，因为我们是中国人！ </p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>长征探究</title>
    <url>/2019/10/13/%E9%95%BF%E5%BE%81/</url>
    <content><![CDATA[<p>读完《红星照耀中国》，对伟大的长征很感兴趣，就对其进行了探究</p>
<span id="more"></span>

<hr>
<h4 id="一：长征起因"><a href="#一：长征起因" class="headerlink" title="一：长征起因"></a>一：长征起因</h4><p>1934年10月，由于博古、李德等人“左”倾冒险主义的错误领导，以及敌强我弱，先后逃离追踪。中央革命根据地（亦称中央苏区）第五次反“围剿”战争遭到失败，红军被迫实行战略性转移，退出中央根据地，进行长征。</p>
<h4 id="二：长征路线"><a href="#二：长征路线" class="headerlink" title="二：长征路线"></a>二：长征路线</h4><p><img src="/D:%5CBlog%5Csource%5Cimages%5Cczls.jpg"></p>
<p>箭头1 红一方面军<a href="https://baike.baidu.com/item/%E9%95%BF%E5%BE%81%E8%B7%AF%E7%BA%BF">长征路线</a>何家冲、金家寨、<a href="https://baike.baidu.com/item/%E6%B3%BE%E5%8E%BF">泾县</a>、<a href="https://baike.baidu.com/item/%E6%97%8C%E5%BE%B7">旌德</a>、<a href="https://baike.baidu.com/item/%E9%99%B6%E5%AE%B6%E6%B2%B3">陶家河</a>、汤口、谭家桥；</p>
<p>箭头2 红两方面军长征路线 分水、淳安、<a href="https://baike.baidu.com/item/%E6%80%80%E7%8E%89%E5%B1%B1">怀玉山</a>、<a href="https://baike.baidu.com/item/%E5%B8%B8%E5%B1%B1">常山</a>、重溪、玉山、江山、横峰；</p>
<p>箭头4 红四方面军长征路线 戈阳、古楼、庆元、<a href="https://baike.baidu.com/item/%E7%A6%8F%E5%AE%89">福安</a>、<a href="https://baike.baidu.com/item/%E5%AE%81%E5%86%88">宁冈</a>、宁化、<a href="https://baike.baidu.com/item/%E4%BA%95%E5%86%88%E5%B1%B1">井冈山</a>、<a href="https://baike.baidu.com/item/%E9%9B%A9%E9%83%BD">雩都</a>；</p>
<p>箭头6 红六军团西征路线 长汀、全州、桂东、信丰、<a href="https://baike.baidu.com/item/%E7%91%9E%E9%87%91">瑞金</a>、<a href="https://baike.baidu.com/item/%E5%AE%81%E8%BF%9C">宁远</a>、汝城、王母渡；</p>
<p>箭头7 红七军团北上路线<a href="https://baike.baidu.com/item/%E5%A4%A7%E7%94%B0/8292">大田</a>、良田、<a href="https://baike.baidu.com/item/%E6%96%B0%E7%94%B0">新田</a>、宜章、城口、安远、<a href="https://baike.baidu.com/item/%E7%95%8C%E9%A6%96">界首</a>、<a href="https://baike.baidu.com/item/%E7%9B%98%E5%8E%BF">盘县</a>、宾川；</p>
<p>箭头10 红十军团北上路线 会泽、绞平渡、<a href="https://baike.baidu.com/item/%E9%9D%96%E5%8E%BF">靖县</a>、<a href="https://baike.baidu.com/item/%E9%BB%94%E8%A5%BF">黔西</a>、<a href="https://baike.baidu.com/item/%E9%81%B5%E4%B9%89">遵义</a>、威信（扎西）、西昌；</p>
<p>箭头25 红二十五军西征路线 <a href="https://baike.baidu.com/item/%E5%A8%84%E5%B1%B1%E5%85%B3">娄山关</a>、木黄、<a href="https://baike.baidu.com/item/%E4%B8%AD%E7%94%B8">中甸</a>、<a href="https://baike.baidu.com/item/%E5%AE%89%E9%A1%BA%E5%9C%BA">安顺场</a>、永顺、<a href="https://baike.baidu.com/item/%E5%A4%A7%E5%BA%B8">大庸</a>、<a href="https://baike.baidu.com/item/%E6%A1%91%E6%A4%8D">桑植</a>、汉源；</p>
<p>红体字为革命根据地以及<a href="https://baike.baidu.com/item/%E6%B8%B8%E5%87%BB%E5%8C%BA">游击区</a> 泸定、天全、名山、懋功、两河口、炉霍、甘孜、苍溪；</p>
<p>大体上：瑞金→突破敌四道防线→强渡乌江→占领遵义→四渡赤水→巧渡金沙江→强渡大渡河→飞夺泸定桥→翻雪山→过草地→陕北吴起会师(1935年10月)→甘肃会宁会师(1936年10月)，宣告长征的胜利结束。</p>
<h4 id="三：长征面临的困难"><a href="#三：长征面临的困难" class="headerlink" title="三：长征面临的困难"></a>三：长征面临的困难</h4><h6 id="1-军事"><a href="#1-军事" class="headerlink" title="1.军事"></a>1.军事</h6><p>国民党反动派的围追堵截。敌军的围追堵截，地上几十万大军前面堵，后边追，左右拦截，这就靠红军和敌人英勇作战。</p>
<h6 id="2-自然"><a href="#2-自然" class="headerlink" title="2.自然"></a>2.自然</h6><p>一路之上天险也可谓多多，有山有水有草地，以血肉之躯去征服，付出了何等的代价，难以言述。</p>
<h6 id="3-生活"><a href="#3-生活" class="headerlink" title="3.生活"></a>3.生活</h6><p>工农红军异常艰苦，没有粮食吃，就吃野菜，甚至吃皮带，皮鞋。长征途中的粮食供应，主要靠打土豪，少数由捐助、欠借方式解决，筹粮筹款成为各部队一大重要任务。</p>
<h6 id="4-内部"><a href="#4-内部" class="headerlink" title="4.内部"></a>4.内部</h6><p>前期的骤然减员&amp;领导人之间的矛盾</p>
<h6 id="5-其它"><a href="#5-其它" class="headerlink" title="5.其它"></a>5.其它</h6><p>无根据地，补给少，医疗条件差</p>
<h4 id="四：长征中具有重大意义的事件–遵义会议"><a href="#四：长征中具有重大意义的事件–遵义会议" class="headerlink" title="四：长征中具有重大意义的事件–遵义会议"></a>四：长征中具有重大意义的事件–遵义会议</h4><p>遵义会议是指1935年1月中共中央政治局在贵州遵义召开的独立自主地解决中国革命问题的一次极其重要的扩大会议。是在红军第五次反“围剿”失败和长征初期严重受挫的情况下，为了纠正博古“左”倾领导在军事指挥上的错误而召开的。</p>
<p>这次会议是中国共产党第一次独立自主地运用马克思列宁主义基本原理解决问题的路线、方针政策的会议。这次会议开始确立实际以毛泽东为代表的马克思主义的正确路线在中共中央的领导地位，挽救了党、挽救了红军、挽救了中国革命，是中国共产党历史上一个生死攸关的转折点。</p>
<h4 id="五：长征的历史价值"><a href="#五：长征的历史价值" class="headerlink" title="五：长征的历史价值"></a>五：长征的历史价值</h4><p>中国共产党领导的<a href="https://www.baidu.com/s?wd=%E4%B8%AD%E5%9B%BD%E5%B7%A5%E5%86%9C%E7%BA%A2%E5%86%9B%E9%95%BF%E5%BE%81&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">中国工农红军长征</a>的胜利，具有极其重要的历史意义。</p>
<p>第一，它粉碎了<a href="https://www.baidu.com/s?wd=%E5%9B%BD%E6%B0%91%E5%85%9A&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">国民党</a>“围剿”红军、消灭革命力量的企图，是中国革命转危为安的关键。</p>
<p>第二，通过长征，把中国革命的大本营放在了西北，这为迎接中国人民抗日救亡的新高潮准备了条件。长征结束后，随着中国共产党倡导建立广泛的<a href="https://www.baidu.com/s?wd=%E6%8A%97%E6%97%A5%E6%B0%91%E6%97%8F%E7%BB%9F%E4%B8%80%E6%88%98%E7%BA%BF&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">抗日民族统一战线</a>，中国革命的新局面开始了。</p>
<p>第三，长征保存并锤炼了中国革命的骨干力量。尽管经历了长征，红军由原来的30万人减少到3万人，但是，这些保存下来的，经历了千锤百炼的骨干，是党和红军极为宝贵的精华。</p>
<p>第四，长征播散了革命的火种。他向沿途的人民群众宣布，只有红军的道路，才是解放他们的道路，只有在中国共产党的领导下，中国各族人民才能翻身解放。</p>
<p>第五，长征铸就了伟大的长征精神。长征精神，就是把全国人民和中华民族的根本利益看过高于一切，坚定革命的理想和信念，坚信正义事业必然胜利的精神；就是为了救国救民，不怕任何艰难险阻，不惜付出一切牺牲的精神；就是坚持独立自主、实事求是，一切从实际出发的精神；就是顾全大局、严守纪律、紧密团结的精神；就是紧紧依靠人民群众，同人民群众生死相依、患难与共、艰难奋斗的精神。</p>
<p>简单的说：在两年中，红军长征转战十四个省，历经曲折，战胜了重重艰难险阻，保存和锻炼了革命的基干力量，将中国革命的大本营转移到了西北，为开展抗日战争和发展中国革命事业创造了条件。</p>
<h4 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h4><p>材料来源于网络，由作者整理汇编而成</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>Test 2019.10.7 题解</title>
    <url>/2019/10/07/Test%202019.10.7/</url>
    <content><![CDATA[<p>这次试卷比较水 <del>我只考了145</del>，前三道是思维题，最后一道考代码功底……</p>
<span id="more"></span>

<h3 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a>题目传送门</h3><p><a href="http://211..140.156.254:2334/problem.php?cid=1068&pid=0">T1</a>		<a href="http://211.140.156.254:2334/problem.php?cid=1068&pid=1">T2</a>		<a href="http://211.140.156.254:2334/problem.php?cid=1068&pid=2">T3</a>		<a href="http://211.140.156.254:2334/problem.php?cid=1068&pid=3">T4</a></p>
<hr>
<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h4 id="T1"><a href="#T1" class="headerlink" title="T1"></a>T1</h4><p>一道模拟的水题，读入后只需要把所有数的最大公因数求出来就行了，建议手打$gcd$.<del>（__gcd）</del></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,a[<span class="number">501</span>];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,a+i);</span><br><span class="line">    <span class="type">int</span> lg = a[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;i++)</span><br><span class="line">        lg = __gcd(lg,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,lg);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T2"><a href="#T2" class="headerlink" title="T2"></a>T2</h4><p>数学题，先拆括号为a1-a2+a2-……+an-1-an，然后化简，得到最大值即为a1-an.</p>
<p>所以我们在读入后对数组排一遍序.</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line"><span class="keyword">for</span>(re i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line"><span class="built_in">sort</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<p>然后就很简单了.</p>
<p>先输出$s[n]$（最大的数）</p>
<p>接着从 $2$ 到 $n-1$ 输出$s[i]$</p>
<p> 最后输出 $s[1]$</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L 100005</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,s[L],f[L];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(re i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">    <span class="built_in">sort</span>(s+<span class="number">1</span>,s+n+<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[n]);</span><br><span class="line">    <span class="keyword">for</span>(re i=<span class="number">2</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,s[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T3"><a href="#T3" class="headerlink" title="T3"></a>T3</h4><p>一道博弈论的题目，考试的时候没想通，直接输出暴了个 $0$ 分</p>
<p>有不懂得地方可以参考下这篇文章: <a href="http://ruanx.pw/post/%E5%8D%9A%E5%BC%88%E8%AE%BA.html">博弈论入门</a></p>
<p><img src="http://172.16.10.56/upload/image/20191007/20191007133842_97184.png"></p>
<p>自己没怎么想懂，先贴代码，以后补坑</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 1039</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> t,n,s[maxn],x,y;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;game.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;game.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;t);</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">        <span class="keyword">for</span>(re i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i]);</span><br><span class="line">        <span class="keyword">for</span>(re i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i])x++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!s[i])<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(re i=n;i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i])y++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(!s[i])<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x%<span class="number">2</span>||y%<span class="number">2</span>)<span class="built_in">printf</span>(<span class="string">&quot;Yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;No\n&quot;</span>);</span><br><span class="line">        x=<span class="number">0</span>,y=<span class="number">0</span>;<span class="built_in">memset</span>(s,<span class="number">0</span>,<span class="built_in">sizeof</span>(s));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T4"><a href="#T4" class="headerlink" title="T4"></a>T4</h4><p><del>他死了.</del></p>
<p>是 状态压缩动态规划 || 记忆化搜索(其实差不多)</p>
<p>我是打了个暴搜，正解还在打</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> re register int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> L 39</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> check(); p=1;for(re j=1;j&lt;=n;j++)<span class="keyword">if</span>(!f[j])p=0;<span class="keyword">if</span>(p)<span class="keyword">if</span>(t&lt;ans)ans=t;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n,s[L][L],f[L],p,ans=<span class="number">214748364</span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> t)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(f[x]||t&gt;ans)<span class="keyword">return</span>;</span><br><span class="line">	f[x]=<span class="number">1</span>;<span class="built_in">check</span>();f[x]=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(re y=<span class="number">1</span>;y&lt;=n;y++)&#123;</span><br><span class="line">		<span class="keyword">if</span>(y==x)<span class="keyword">continue</span>;</span><br><span class="line">		f[x]=<span class="number">1</span>;<span class="built_in">dfs</span>(y,t+s[x][y]);f[x]=<span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">	<span class="keyword">for</span>(re i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">		<span class="keyword">for</span>(re j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">			<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;s[i][j]);</span><br><span class="line">	<span class="keyword">for</span>(re i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">dfs</span>(i,<span class="number">0</span>);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,ans);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h5><p>这好像是我留坑最多的题解了…..</p>
]]></content>
      <tags>
        <tag>考试</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>深夜失眠记</title>
    <url>/2019/09/08/%E6%B7%B1%E5%A4%9C%E5%A4%B1%E7%9C%A0%E8%AE%B0/</url>
    <content><![CDATA[<p>深夜，1:40.</p>
<p>躺在床上，辗转反侧.</p>
<span id="more"></span>

<p>打开笔记本，想了很多，写了很多，删了很多.</p>
<p>回想初一这一年，点点滴滴.</p>
<p>我一直想像小学一样，认识很多的朋友，结交很多的知音.</p>
<p>然而，现实却甩了我几个大嘴巴子.</p>
<p>我怕得罪人，不敢要求太多，不敢乱说话，怕对方不高兴，诚惶诚恐的面对所有”朋友”。</p>
<p>遗憾的是，我并没有得到他们相应的尊重。后来，我开始宠爱和迁就自己，你迟到我先走，不想做绝不勉强，多顾个人感受，其他人关我屁事…</p>
<p>不管再怎么争取，这世上永远只有一小部分人喜欢你。</p>
]]></content>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
  <entry>
    <title>动态规划</title>
    <url>/2019/09/05/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>从<strong>取硬币</strong>开始谈起：</p>
<span id="more"></span>

<p>假设您是个土豪，身上带了足够的1，5，10，20，50，100元面值的钞票。现在您的目标是凑出某个金额 w ，需要用到尽量少的钞票。</p>
<p>显然我们可以用<strong>“贪心”</strong>的策略来解决这个问题：能用100就尽量用100，否则用50，以此类推。</p>
<p>贪心策略会尽快让  <strong>w</strong>  变得更小。能让 <strong>w</strong> 少100就尽量让它少100，这样我们接下来面对的局面就是凑出 <strong>w-100</strong>。长期的生活经验表明，贪心策略是正确的。但是，如果我们换一组钞票的面值，贪心策略就也许不成立了。如果一个<strong>奇葩国家</strong>的钞票面额分别是</p>
<p>1、5、11,那么我们在凑出15的时候，贪心策略会出错： </p>
<p>15&#x3D;1×11+4×1 （贪心策略使用了5张钞票） 15&#x3D;3×5 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">（正确的策略，只用3张钞票） </span><br></pre></td></tr></table></figure>

<p>为什么会这样呢？贪心策略错在了哪里？</p>
<p><strong>鼠目寸光.</strong></p>
<p>贪心是一种<strong>只考虑眼前情况</strong>的策略</p>
<h2 id="动态转移方程"><a href="#动态转移方程" class="headerlink" title="动态转移方程"></a>动态转移方程</h2><p>重新分析刚刚的例子。w&#x3D;15时，我们如果取11，接下来就面对w&#x3D;4的情况；如果取5，则接下来面对</p>
<p>w&#x3D;10的情况。我们发现这些问题都有相同的形式：“给定<strong>w</strong>，凑出<strong>w</strong>所用的最少钞票是多少张？”</p>
<p>接下来，我们用</p>
<p>f(n)来表示“凑出n所需的最少钞票数量”。</p>
<p>那么，如果我们取了11，最后的代价（用掉的钞票总数）是多少呢？ 明显cost  &#x3D; f(4)+1 &#x3D; 4+1 &#x3D;  5,它的意义是：利用11来凑出15，付出的代价等于f(4)加上自己这一张钞票。现在我们暂时不管f(4)怎么求出来。  依次类推，马上可以知道：如果我们用5来凑出15，cost就是<strong>f(10)+1 &#x3D; 2+1 &#x3D; 3</strong></p>
<p>那么，现在w&#x3D;15的时候，我们该取那种钞票呢？当然是各种方案中，<strong>cost</strong>值最低的那一个！</p>
<p>取11：<img src="https://img2018.cnblogs.com/blog/1648105/201905/1648105-20190518211825454-1540987748.png" alt="img"></p>
<p>取5：<img src="https://img2018.cnblogs.com/blog/1648105/201905/1648105-20190518211831591-1589645221.png" alt="img"></p>
<p>取1：<img src="https://img2018.cnblogs.com/blog/1648105/201905/1648105-20190518211838441-1041229314.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">显而易见，cost值最低的是取5的方案。我们通过上面三个式子，做出了正确的决策！</span><br></pre></td></tr></table></figure>

<p>这给了我们一个至关重要的启示—— <img src="https://img2018.cnblogs.com/blog/1648105/201905/1648105-20190518212032951-2054044526.png" alt="img"><br>相关；</p>
<p>更确切地说：<img src="https://img2018.cnblogs.com/blog/1648105/201905/1648105-20190518212043053-647523586.png" alt="img"></p>
<p>这个式子是非常激动人心的。这个式子也就是所谓的动态规划的<strong>状态转移方程</strong>，我们要求出f(n)，只需要求出几个更小的f值；既然如此，我们从小到大把所有的 <strong>f(i)</strong> 求出来不就好了？</p>
<p>我们以 <strong>O(n)</strong> 的复杂度解决了这个问题。现在回过头来，我们看看它的原理：<br><img src="https://img2018.cnblogs.com/blog/1648105/201905/1648105-20190518212048218-1069822706.png" alt="img"></p>
<p>这两个事实，保证了我们做法的正确性。它比起贪心策略，会分别算出取1、5、11的代价，从而做出一个正确决策，这样就避免掉了<strong>“鼠目寸光”！</strong><br>它与暴力的区别在哪里？我们的暴力枚举了“使用的硬币”，然而这属于冗余信息。我们要的是答案，根本不关心这个答案是怎么凑出来的。譬如，要求出f(15)，只需要知道f(14),f(10),f(4)的值。其他信息并不需要。我们舍弃了冗余信息。我们只记录了对解决问题有帮助的信息——f(n).我们能这样干，取决于问题的性质：求出f(n)，只需要知道几个更小的f(c)。我们将求解f(c)称作求解f(n)的“子问题”。</p>
<p>这就是<strong>DP</strong>（动态规划，dynamic programming）</p>
<p>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</p>
<p>思考题：请稍微修改代码，输出我们凑出w的方案。  </p>
<h3 id="几个简单原则"><a href="#几个简单原则" class="headerlink" title="几个简单原则"></a>几个简单原则</h3><p>【无后效性】</p>
<p>一旦f(n)确定，“我们如何凑出f(n)”就<strong>再也用不着了</strong>。要求出f(15)，只需要知道f(14),f(10),f(4)的值，而</p>
<p>f(14),f(10),f(4)是如何算出来的，对之后的问题没有影响。</p>
<p>“未来与过去无关”，这就是<strong>无后效性</strong>.<br>（严格定义：如果给定某一阶段的状态，则在这一阶段以后过程的发展不受这阶段以前各段状态的影响。）</p>
<p>【最优子结构】<br>回顾我们对f(n)定义：我们记“凑出n所需的最少钞票数量”为f(n).<br>f(n)的定义就已经蕴含了“最优”。利用w&#x3D;14,10,4的最优解，我们即可算出w&#x3D;15的最优解。<br>大问题的最优解可以由小问题的最优解推出，这个性质叫做<strong>“最优子结构性质”</strong>.</p>
<p>引入这两个概念之后，我们如何判断一个问题能否使用DP解决呢？能将大问题拆成几个小问题，且满足无后效性、最优子结构性质。</p>
<h3 id="动态规划的解题思路"><a href="#动态规划的解题思路" class="headerlink" title="动态规划的解题思路"></a>动态规划的解题思路</h3><p>【DP的操作过程】<br>一言以蔽之：</p>
<p>大事化小，小事化了。</p>
<p>将一个大问题转化成几个小问题；      求解小问题；        推出大问题的解。</p>
<p>【如何设计DP算法】</p>
<p>下面介绍比较通用的设计DP算法的步骤。首先，把我们面对的局面表示为x。这一步称为设计状态。 对于状态x，记我们要求出的答案(e.g.  最小费用)为f(x).我们的目标是求出f(T).  找出f(x)与哪些局面有关（记为p），写出一个式子（称为状态转移方程），通过f(p)来推出f(x).</p>
<p>【DP三连】<br>设计DP算法，往往可以遵循DP三连：</p>
<p>我是谁？ ——设计状态，表示局面             我从哪里来？      我要到哪里去？ ——设计转移</p>
<p>设计状态是DP的基础。接下来的设计转移，有两种方式：一种是考虑我从哪里来（本文之前提到的两个例子，都是在考虑”我从哪里来”）；另一种是考虑我到哪里去，这常见于求出f(x)之后，更新能从x走到的一些解。这种DP也是不少的，我们以后会遇到。</p>
<h3 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h3><p><strong>最长上升子序列（LIS）问题</strong>：</p>
<p>给定长度为n的序列a，从a中抽取出一个子序列，这个子序列需要单调递增。问最长的上升子序列（</p>
<p>LIS）的长度。 e.g. 1,5,3,4,6,9,7,8的LIS为1,3,4,6,7,8，长度为6。</p>
<p>如何设计状态（我是谁）？</p>
<p>状态x从哪里推过来（我从哪里来）？</p>
]]></content>
      <tags>
        <tag>算法</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>建站历程</title>
    <url>/2019/08/30/%E5%BB%BA%E7%AB%99%E5%8E%86%E7%A8%8B/</url>
    <content><![CDATA[<hr>
<p>本小站建立以来的历程</p>
<span id="more"></span>

<h2 id="2019年"><a href="#2019年" class="headerlink" title="2019年"></a>2019年</h2><h3 id="八月"><a href="#八月" class="headerlink" title="八月"></a>八月</h3><p>2019,8,7       开通blog</p>
<p>2019,8,15     成功开通blog评论功能        <del>ps:现在又废了</del></p>
<p>2019,8,29     略微美化blog</p>
<h3 id="九月"><a href="#九月" class="headerlink" title="九月"></a>九月</h3><p>2019,9,6      成功绑定域名 jfyblog.xyz</p>
<p>2019,9,7      更新yelee主题                   <del>(的确比yilia美观一些)</del></p>
<p>2019,9,12    美化博客（添加github图标,左侧边栏添加音乐和滚动字体，右下角添加板娘）</p>
<h3 id="十月"><a href="#十月" class="headerlink" title="十月"></a>十月</h3><p>2019,10,1~2019,10,11   更新next主题，并适当加了一些美化</p>
]]></content>
  </entry>
  <entry>
    <title>暑假集训总结</title>
    <url>/2019/08/26/%E6%9A%91%E5%81%87%E9%9B%86%E8%AE%AD%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p>emm,暑假集训转眼就要过去了，虽说这段时间状态有所下滑，但也学到了不少新的知识：</p>
<span id="more"></span>

<p>1.初赛的相关知识(电脑常识，反码补码，<del>CCF赞歌</del>)</p>
<p>2.部分模板(排序，数论，快速幂)</p>
<p>3.考试的一些经验，心态，以及各种骗分，优化</p>
<p>在本次集训中，也发现了自己<strong>很多的不足</strong>:</p>
<p>1.考试的时候像在做梦，考差之后才会认真做题。</p>
<p>2.心浮气躁，每道题的特殊数据点总是会没有想到，导致第一题和第二题都有大量失分的情况</p>
<p>3.思维有些固定化，每道题基本上都是一个个板子打出来的</p>
<p>…….</p>
<p>总之，还有诸多的不足，希望自己在剩下的十天能加以改进，以备下一次集训时能向前冲！</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">while</span>(day++)&#123;</span><br><span class="line">  	hard++;</span><br><span class="line">	scoure++;</span><br><span class="line">	NOIP++;</span><br><span class="line">  	<span class="keyword">if</span>(scoure&gt;<span class="number">300</span>)<span class="built_in">printf</span>(<span class="string">&quot;省一！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>随笔</tag>
        <tag>集训</tag>
      </tags>
  </entry>
  <entry>
    <title>快读&amp;快写模板</title>
    <url>/2019/08/16/%E5%BF%AB%E8%AF%BB%E5%BF%AB%E5%86%99/</url>
    <content><![CDATA[<p>快读和快写，就是利用字符串的一些特殊性质进行读入，输出；在一定情况下（输入数据十分庞大），可以大大的缩短时间。</p>
<span id="more"></span>

<p>注意这个快读是非常的重要的，我想这应该是想要在OI这条路上走远的所有OIer必须会的东西。养成每次写题目都加上快读的好习惯，有可能会在关键的时候救你一命！</p>
<h3 id="普通快读"><a href="#普通快读" class="headerlink" title="普通快读"></a>普通快读</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline void read(int &amp;x)&#123;</span><br><span class="line">   int s = 0, w = 1; char ch = getchar();</span><br><span class="line">   while(ch &lt; &#x27;0&#x27; || ch &gt; &#x27;9&#x27;)&#123; if(ch == &#x27;-&#x27;) w = -1; ch = getchar(); &#125;</span><br><span class="line">   while(ch &gt;= &#x27;0&#x27; &amp;&amp; ch &lt;= &#x27;9&#x27;) s = s * 10 + ch - &#x27;0&#x27;, ch = getchar();</span><br><span class="line">   x = s*w;</span><br><span class="line">   return ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>getchar ，就是将数字当字符读取，比scanf快很多<br>w用来判断数字是不是负号，如果想的话可以再压一下行</p>
<h3 id="普通快写"><a href="#普通快写" class="headerlink" title="普通快写"></a>普通快写</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">inline void out(int a)&#123;</span><br><span class="line">    if(x&lt;0)&#123;</span><br><span class="line">        putchar(&#x27;-&#x27;);</span><br><span class="line">        x=-x;</span><br><span class="line">    &#125;</span><br><span class="line">    if(a&gt;9)write(x/10);</span><br><span class="line">    putchar(a%10+&#x27;0&#x27;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快写也非常简单，利用int与ASCII码之间转换，实现快读快写的目的。</p>
<p>最后来一发<strong>灵魂快读</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">int read()&#123;</span><br><span class="line">    int a</span><br><span class="line">    cin&gt;&gt;a;</span><br><span class="line">    return a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>模板</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title>Test 2019.8.14 题解</title>
    <url>/2019/08/14/Test%202019.8.14/</url>
    <content><![CDATA[<h3 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><strong>题目传送门</strong></h3><p><a href="http://211.140.156.254:2334/problem.php?cid=1058&pid=0">T1</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1058&pid=1">T2</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1058&pid=2">T3</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1058&pid=3">T4</a>           <a href="http://211.140.156.254:2334/problem.php?cid=1058&pid=4">T5</a></p>
<span id="more"></span>

<hr>
<iframe border="0" marginwidth="0" marginheight="0" src="https://music.163.com/outchain/player?type=2&amp;id=1349292048&amp;auto=1&amp;height=66" width="330" height="86" frameborder="no"></iframe>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h5 id="T1-NBA-总冠军"><a href="#T1-NBA-总冠军" class="headerlink" title="T1 NBA 总冠军"></a>T1 NBA 总冠军</h5><p>一看题面，哎哎哟，不是一道超级水题吗，啪啪啪，飞速的打完代码，一过样例，直接提交。</p>
<p>但是，但是，这这这 <del>作为一个观看NBA10几年的老粉</del>。居然没有想到洛杉矶湖人（Los angels）。</p>
<p>好吧，这看似简单的题面难度瞬间上了一个档次：</p>
<p>1.geline       读入</p>
<p>2.分出名字和时间</p>
<p>3.去掉c里的时间</p>
<p>4.结构体排序</p>
<p>5.边去重边输出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">using namespace std;</span><br><span class="line">struct NBA&#123;string c;int t;&#125;a[51];</span><br><span class="line">int n,x;</span><br><span class="line">bool cmp(NBA x,NBA y)&#123;return x.t&lt;y.t;&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d\n&quot;,&amp;n);</span><br><span class="line">    for(int i=1;i&lt;=n;++i)&#123;</span><br><span class="line">        getline(cin,a[i].c);</span><br><span class="line">        x=0;</span><br><span class="line">        for(int j=0;j&lt;a[i].c.length();++j)</span><br><span class="line">            if((a[i].c[j]&gt;=&#x27;0&#x27;)&amp;&amp;(a[i].c[j]&lt;=&#x27;9&#x27;))x=x*10+a[i].c[j]-&#x27;0&#x27;;   //查找时间</span><br><span class="line">        a[i].t=x;a[i].c.erase(a[i].c.size()-5,5);   //去掉字符串的时间</span><br><span class="line">    &#125;</span><br><span class="line">    sort(a+1,a+n+1,cmp);   //结构体排序</span><br><span class="line">    for(int i=1;i&lt;=n;++i)</span><br><span class="line">        if(a[i].t!=a[i-1].t)   //去重</span><br><span class="line">            cout&lt;&lt;a[i].t&lt;&lt;&quot; &quot;&lt;&lt;a[i].c&lt;&lt;endl;    //输出</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>ps:因为 <del>本blog猪</del> 的代码仍未调试正确，本代码来自:<a href="https://www.luogu.org/blog/gzhqyx/nba-zong-guan-jun">https://www.luogu.org/blog/gzhqyx/nba-zong-guan-jun</a></p>
<p><del>blog猪</del> 的代码本地CCR是正确的，在 Linux 的评测机上却错了，据说是因为回车上的玄学问题……</p>
<hr>
<h5 id="T2-骑马修栅栏"><a href="#T2-骑马修栅栏" class="headerlink" title="T2 骑马修栅栏"></a>T2 骑马修栅栏</h5><p>吃了没文化的亏，一直以为是连通块的问题，打了个暴搜，最后老师讲评才知道是一道欧拉环的问题。判断每个点的入度是不是都为偶数，如果是输出”Can be achieve”,否则记录点，输出”Can not be achieve”.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">using namespace std;</span><br><span class="line">int s[539],n,a,b,x[4],y=1;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(re i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;,&amp;a,&amp;b);s[a]++,s[b]++;   //记录入度</span><br><span class="line">    &#125;</span><br><span class="line">    for(re i=1;i&lt;=530;i++)&#123;</span><br><span class="line">        if(s[i]%2)x[y++]=i;   //如果入度为奇数，则记录</span><br><span class="line">    &#125;</span><br><span class="line">    if(x[1])&#123;     //如果x[1]被记录过</span><br><span class="line">        printf(&quot;Can not be achieve\n&quot;);   //输出</span><br><span class="line">        printf(&quot;%d %d&quot;,x[1],x[2]);    //输出</span><br><span class="line">    &#125;</span><br><span class="line">    else printf(&quot;Can be achieve&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="T3-传话"><a href="#T3-传话" class="headerlink" title="T3 传话"></a>T3 传话</h5><h2 id="一道图论题-我考试的时候打了个假的图论-邻接矩阵-，n4的复杂度……思路很乱。正解的话应该是用邻接表，枚举时仅用n的复杂度就行，搜索的话看优化，最多可以到m的复杂度，所以最后复杂度是O-nm"><a href="#一道图论题-我考试的时候打了个假的图论-邻接矩阵-，n4的复杂度……思路很乱。正解的话应该是用邻接表，枚举时仅用n的复杂度就行，搜索的话看优化，最多可以到m的复杂度，所以最后复杂度是O-nm" class="headerlink" title="一道图论题,我考试的时候打了个假的图论(邻接矩阵)，n4的复杂度……思路很乱。正解的话应该是用邻接表，枚举时仅用n的复杂度就行，搜索的话看优化，最多可以到m的复杂度，所以最后复杂度是O(nm)"></a>一道<strong>图论题</strong>,我考试的时候打了个假的图论(邻接矩阵)，n4的复杂度……<del>思路很乱</del>。正解的话应该是用邻接表，枚举时仅用n的复杂度就行，搜索的话看优化，最多可以到m的复杂度，所以最后复杂度是O(nm)</h2><h5 id="T4-硬币"><a href="#T4-硬币" class="headerlink" title="T4 硬币"></a>T4 硬币</h5><p>一道完全背包+拆分。因为考虑到数字的浮动性，所以我们可以把硬币的重量拆分出来，例:5 40 41可拆分成5 40和5 41;</p>
]]></content>
      <tags>
        <tag>考试</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Test 2019.8.13 题解</title>
    <url>/2019/08/13/Test%202019.8.13/</url>
    <content><![CDATA[<h3 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><strong>题目传送门</strong></h3><p><a href="http://211.140.156.254:2334/problem.php?cid=1057&pid=0">T1</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1057&pid=1">T2</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1057&pid=2">T3</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1057&pid=3">T4</a></p>
<span id="more"></span>

<hr>
<iframe border="0" marginwidth="0" marginheight="0" src="https://music.163.com/outchain/player?type=2&amp;id=1349292048&amp;auto=1&amp;height=66" width="330" height="86" frameborder="no"></iframe>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h3><h5 id="T1-自数"><a href="#T1-自数" class="headerlink" title="T1 自数"></a>T1 自数</h5><p>题面较为简单，给出了一个概念：一个数可以产生一个由它本身加上各个位数上的数之和的数(有点拗口)，求l到r区间的所有不能被产生的数(相当于这个概念里的质数)。</p>
<p>解析：其实比较简单，数据也就1000000，可以定义一个 bool 数组，‘’1‘’代表该数是被产生的，’’0’’表示该数不能被产生，<strong>i</strong> 从 1 跑到 r,打一张表出来，最后从l 跑到 r，判断如果 !f[i]就输出。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">#define L 100039</span><br><span class="line">using namespace std;</span><br><span class="line">int l,r,f[L],j,sum;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;l,&amp;r); //读入</span><br><span class="line">    for(re i=1;i&lt;=r+1;i++)&#123;</span><br><span class="line">        int t=i;sum=t;  //sum用来记录每次产生数的值，t用来储存i的值</span><br><span class="line">        while(t)&#123;sum+=t%10;t/=10;&#125; //记录产生数的总和</span><br><span class="line">        f[sum]=1;//还原</span><br><span class="line">    &#125;</span><br><span class="line">    for(re i=l;i&lt;=r;i++)&#123;</span><br><span class="line">        if(!f[i])printf(&quot;%d\n&quot;,i); //输出</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="T2-侦察守卫"><a href="#T2-侦察守卫" class="headerlink" title="T2 侦察守卫"></a>T2 侦察守卫</h5><p>非常简单的一道模拟题，因为数据范围十分小，所以可以直接暴力枚举</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">#define L 139</span><br><span class="line">using namespace std;</span><br><span class="line">int f[L][L],q,r;</span><br><span class="line">struct FLY&#123;int x,y,xx,yy;&#125;s1,s2;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d %d %d %d&quot;,&amp;s1.x,&amp;s1.y,&amp;s1.xx,&amp;s1.yy);</span><br><span class="line">    scanf(&quot;%d %d %d %d&quot;,&amp;s2.x,&amp;s2.y,&amp;s2.xx,&amp;s2.yy);</span><br><span class="line">    for(re i=s1.x;i&lt;s1.xx;++i)</span><br><span class="line">        for(re j=s1.y;j&lt;s1.yy;++j)</span><br><span class="line">            ++f[i][j];</span><br><span class="line">    for(re i=s2.x;i&lt;s2.xx;++i)</span><br><span class="line">        for(re j=s2.y;j&lt;s2.yy;++j)</span><br><span class="line">            ++f[i][j];</span><br><span class="line">    for(re i=1;i&lt;=100;++i)</span><br><span class="line">        for(re j=1;j&lt;=100;++j)</span><br><span class="line">            if(f[i][j]==1)++r;</span><br><span class="line">            else if(f[i][j]==2)++q;</span><br><span class="line">    printf(&quot;%d %d %d&quot;,q,r,10000-q-r);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="T3-放牙刷"><a href="#T3-放牙刷" class="headerlink" title="T3 放牙刷"></a>T3 放牙刷</h5><p>一道递推题，递推公式为f[i+1]&#x3D;(f[i-1]+f[i])*i;</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">#defnie LL long long</span><br><span class="line">using namespace std;</span><br><span class="line">LL n,f[1000039];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    if(n==1)&#123;printf(&quot;No Solution&quot;);return 0;&#125;</span><br><span class="line">    f[2]=1;f[3]=2;</span><br><span class="line">    for(re i=3;i&lt;=n;i++)&#123;</span><br><span class="line">        f[i+1]=((f[i-1]+f[i])%1206)*(i%1206);</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%lld&quot;,f[n]%1206);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="T4-安全逃离"><a href="#T4-安全逃离" class="headerlink" title="T4 安全逃离"></a>T4 安全逃离</h5><p>也是一道模拟题，十分简单，先读入，之后把每个点拿走枚举一遍，如果可行，p++。最后一个特判：当p等于奶牛总数加一时输出‘’1‘’（因为每个奶牛撤走都行就代表这个地图是安全的），当p&#x3D;&#x3D;1（初始化值）时输出‘’-1‘‘，最后输出奶牛编号</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">#define L 139</span><br><span class="line">using namespace std;</span><br><span class="line">int f[L][L],n,m,x[L],y[L],s,i,j,z,ans[L],k,p=1;</span><br><span class="line">bool bx,by,b=1;</span><br><span class="line">int scin()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;,&amp;n,&amp;m),scanf(&quot;%d&quot;,&amp;s);</span><br><span class="line">    for(i=1;i&lt;=s;i++)&#123;scanf(&quot;%d%d&quot;,&amp;x[i],&amp;y[i]);f[x[i]][y[i]]=1;&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scin();</span><br><span class="line">    for(k=1;k&lt;=s;k++)&#123;</span><br><span class="line">        f[x[k]][y[k]]=0;</span><br><span class="line">        for(z=1;z&lt;=s;z++)&#123;</span><br><span class="line">            if(z==k)continue;</span><br><span class="line">            bx=0,by=0;</span><br><span class="line">            for(i=x[z]-1;i&gt;=1;i--)if(f[i][y[z]])bx=1;</span><br><span class="line">            for(j=y[z]+1;j&lt;=m;j++)if(f[x[z]][j])by=1;</span><br><span class="line">            if(bx&amp;&amp;by)b=0;</span><br><span class="line">        &#125;</span><br><span class="line">        if(b)ans[p++]=k;</span><br><span class="line">        f[x[k]][y[k]]=1;b=1;</span><br><span class="line">    &#125;</span><br><span class="line">    if(p==s+1)printf(&quot;0&quot;);</span><br><span class="line">    else if(p&gt;1)for(i=1;i&lt;p;i++)printf(&quot;%d\n&quot;,ans[i]);</span><br><span class="line">    else printf(&quot;-1&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>考试</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Test 2019.8.11 题解</title>
    <url>/2019/08/11/Test%202019.8.11/</url>
    <content><![CDATA[<h3 id="题目传送门"><a href="#题目传送门" class="headerlink" title="题目传送门"></a><strong>题目传送门</strong></h3><p><a href="http://211.140.156.254:2334/problem.php?cid=1055&pid=0">T1</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1055&pid=1">T2</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1055&pid=2">T3</a>          <a href="http://211.140.156.254:2334/problem.php?cid=1055&pid=3">T4</a></p>
<span id="more"></span>

<hr>
<iframe border="0" marginwidth="0" marginheight="0" src="https://music.163.com/outchain/player?type=2&amp;id=1349292048&amp;auto=1&amp;height=66" width="330" height="86" frameborder="no"></iframe>

<h3 id="题解"><a href="#题解" class="headerlink" title="题解"></a><strong>题解</strong></h3><h5 id="T1-买鸡"><a href="#T1-买鸡" class="headerlink" title="T1 买鸡"></a>T1 买鸡</h5><p>这道题题面较为简单，很容易想到无脑暴力。打着 <strong>三维</strong> 的暴力，嘴里哼着小曲，一切会体面，woc数据范围有 <strong>20000</strong> ！！！转念一想，觉得还是有很大优化空间的，于是三维的暴力就成了二维的n方暴力，代码如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,s1,s2,t;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);   //输入，ps:本人在此将m当成钱，n当成只数.</span><br><span class="line">	for(re i=0;i&lt;=n;i++)&#123;     //枚举过程，从0只公鸡枚举到n只公鸡.</span><br><span class="line">		s1=i*5;    //买i只公鸡所花的钱</span><br><span class="line">		for(re j=0;j&lt;=n;++j)&#123;   //从0只母鸡枚举到n只母鸡.</span><br><span class="line">			s2=j*3;    //买i只母鸡所花的钱.</span><br><span class="line">            t=(m-s1-s2)*3;    //m-s1-s2是剩下的钱，因为一元钱可以买三只鸡，所以乘3.</span><br><span class="line">			if(t+i+j==n)printf(&quot;%d %d %d\n&quot;,i,j,t);//如果买的鸡数等于题目要求数，输出</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><del>没有优化的还是比较简单无脑的</del></p>
<p>但是，有的 DL 就会提出疑问了，n方的复杂度，20000<strong>不是也会超时吗</strong>？</p>
<p><em>正确！</em></p>
<p>当 <strong>i</strong> 为 <strong>k</strong> 时，<strong>j</strong> 能取的最大值为 <strong>n-k</strong>.</p>
<p>所以我们还可以优化 <strong>j</strong> 循环的次数，在数据较大时能砍下不少常数. <del>(浪费时间)</del></p>
<p>得到以下伪代码:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">for(i=0;i&lt;=n;++i)&#123;</span><br><span class="line">    for(j=0;j&lt;=n-i;++j)&#123;  //优化为n-i</span><br><span class="line">    	····</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>很多人以为这样就优化完了，实则不然，再细看题面，发现还可以优化，在 <strong>i</strong> 循环的过程中，可以将循环的最大值设为 <strong>min(m&#x2F;5,n)</strong> ,为什么呢？因为m为钱,一只公鸡需要5元，那么最多买的公鸡数则为<strong>m&#x2F;5</strong>   <del>(ps:买不起)</del>。同理，j也是如此。</p>
<p>最终得到以下代码（仅供参考）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,s1,s2,s3,t;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d%d&quot;,&amp;m,&amp;n);</span><br><span class="line">	for(re i=0;i&lt;=min(m/5,n);++i)&#123;</span><br><span class="line">		s1=i*5;</span><br><span class="line">		for(re j=0;j&lt;=min(m-i*5,n-i);++j)&#123;</span><br><span class="line">			s2=j*3;t=(m-s1-s2)*3;</span><br><span class="line">			if(t+i+j==n)printf(&quot;%d %d %d\n&quot;,i,j,t);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="T2-勾股数"><a href="#T2-勾股数" class="headerlink" title="T2 勾股数"></a>T2 勾股数</h5><p>本人目前能力有限，还暂时不会订正，先放一下本人的暴力代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">#define fly(a,b,c) for(re a=b;a&lt;=c;a++)</span><br><span class="line">using namespace std;</span><br><span class="line">int r,k;</span><br><span class="line">long long s1,s2,ans;</span><br><span class="line">int check(long long n)&#123;</span><br><span class="line">	if(sqrt(n)*sqrt(n)==n)return 1;</span><br><span class="line">	else return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">	scanf(&quot;%d&quot;,&amp;r);</span><br><span class="line">	fly(i,1,r)&#123;</span><br><span class="line">		s1=i*i;</span><br><span class="line">		fly(j,i,r)&#123;</span><br><span class="line">			s2=j*j;</span><br><span class="line">			if(check(s1+s2))&#123;</span><br><span class="line">				++j,++ans,k=sqrt(s1+s2);</span><br><span class="line">				printf(&quot;%d %d %d\n&quot;,i,j,k);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	printf(&quot;%d&quot;,ans);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="T3-ISBN码"><a href="#T3-ISBN码" class="headerlink" title="T3 ISBN码"></a>T3 ISBN码</h5><p>em,与洛谷的一道题目有些相似:<a href="https://www.luogu.org/problem/P1055">传送门</a></p>
<p>一道超简单的字符串模拟，就是处理有点繁琐而已。</p>
<p>1.读入，获取字符长度 <del>（等于没说）</del></p>
<p>2.按照ISBN的顺序求一个sum，记录”?”的出现位置</p>
<p>3.枚举</p>
<p>4.特判</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define re register int</span><br><span class="line">#define r (10-i)</span><br><span class="line">using namespace std;</span><br><span class="line">char s[39];</span><br><span class="line">int sum,l,p,k[39];</span><br><span class="line">int main()&#123;</span><br><span class="line">	freopen(&quot;isbn.in&quot;,&quot;r&quot;,stdin);</span><br><span class="line">	freopen(&quot;isbn.out&quot;,&quot;w&quot;,stdout);</span><br><span class="line">	cin&gt;&gt;s,l=strlen(s);</span><br><span class="line">	for(re i=0;i&lt;l;i++)&#123;</span><br><span class="line">		if(s[i]!=&#x27;X&#x27;&amp;&amp;s[i]!=&#x27;?&#x27;)k[i+1]=(s[i]-&#x27;0&#x27;)*r,sum+=k[i+1];</span><br><span class="line">		else if(s[i]==&#x27;?&#x27;)p=i;</span><br><span class="line">		else if(s[i]==&#x27;X&#x27;)k[i+1]=10*r,sum+=k[i+1];</span><br><span class="line">	&#125;</span><br><span class="line">	for(re i=0;i&lt;=10;i++)&#123;</span><br><span class="line">		if((sum+i*(10-p))%11==0&amp;&amp;i!=10)&#123;</span><br><span class="line">			printf(&quot;%d&quot;,i);</span><br><span class="line">			return 0;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	if(p==9)printf(&quot;X&quot;);</span><br><span class="line">	else printf(&quot;-1&quot;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h5 id="T4-对角线"><a href="#T4-对角线" class="headerlink" title="T4 对角线"></a>T4 对角线</h5><p>一道十分简单的模拟题，首先打出横竖两行应该是很简单的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scanf(&quot;%d%d%d&quot;,&amp;n,&amp;x,&amp;y);</span><br><span class="line">FLY(i,1,n)printf(&quot;(%d,%d)&quot;,x,i);</span><br><span class="line">FLY(j,1,n)printf(&quot;(%d,%d)&quot;,j,y);</span><br><span class="line">//（注:FLY是自己码风的问题，总的来说是for(register int a=b;a&lt;=c;a++)）</span><br></pre></td></tr></table></figure>

<p>然后斜着两条略有一点难度,我的做法挺简单，但码量有点大</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xx=x,yy=y;</span><br><span class="line">while(xx&gt;1&amp;&amp;yy&gt;1)&#123;--xx;--yy;&#125;</span><br></pre></td></tr></table></figure>

<p>首先用 xx,yy 来定位(x,y),接着往左上方搜，如果到了对角线的顶点，就停止记录，接着是输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(xx&lt;=n&amp;&amp;yy&lt;=n)&#123;printf(&quot;(%d,%d)&quot;,xx++,yy++);&#125;</span><br></pre></td></tr></table></figure>

<p>同理可得另外一条斜边的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(xx&lt;n&amp;&amp;yy&gt;1)&#123;++xx;--yy;&#125;</span><br><span class="line">while(xx&gt;0&amp;&amp;yy&lt;=n)&#123;printf(&quot;(%d,%d)&quot;,xx--,yy++);&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>考试</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Test 2019.5.19 题解</title>
    <url>/2019/05/19/Test%202019.5.19/</url>
    <content><![CDATA[<p>日常学校考试，这次试卷大致是 一道字符串处理 + 一道二分 + 一道看起来十分像DFS的动规，期望值210，实际180，100+80+0.好吧还是看下试卷.</p>
<span id="more"></span>

<p>T1: <a href="https://www.luogu.org/problemnew/show/P4470">传送门</a></p>
<p>T2: <a href="https://blog.csdn.net/weixin_41443764/article/details/90346576">传送门</a></p>
<p>T3: <a href="http://211.140.156.254:2334/problem.php?cid=1036&pid=2">传送门</a></p>
<h4 id="T1："><a href="#T1：" class="headerlink" title="T1："></a>T1：</h4><p>一道简单的字符串处理 （模拟），也就打了一个小时。原理和现实生活相近，类似于智能推荐的输入按键。模拟题意，逐个判断（简单易懂）。这道题认真模拟，注意最后输出的换行顺序就好。</p>
<p>本题思路</p>
<ul>
<li>先输入n个，目的地名称，再输入已经输进去的字母</li>
<li>然后对于每一个输入进去的字母都进行判断是否和目的地一致（只要有一个不一样就做标记，在最后搜索时跳过）</li>
<li>对于每一个目的地，只要没被做过标记那么他的没输入的下一个字母就在输出的表数组上记录</li>
<li>最后输出一个表</li>
</ul>
<p>AC代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">char f[60][110],c[259];</span><br><span class="line">int i,n,ans[27],k=-1,l;</span><br><span class="line">bool b[90];</span><br><span class="line">void print()&#123;</span><br><span class="line">    printf(&quot;***&quot;);</span><br><span class="line">    for(i=1;i&lt;=26;i++)&#123;</span><br><span class="line">        if(ans[i])cout&lt;&lt;char(i+64);</span><br><span class="line">        else printf(&quot;*&quot;);</span><br><span class="line">        if((i+3)%8==0 &amp;&amp; i&gt;4)cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;***&quot;);</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    for(i=1;i&lt;=n;i++)cin&gt;&gt;f[i];</span><br><span class="line">    cin&gt;&gt;c;</span><br><span class="line">    l = strlen(c);</span><br><span class="line">    while(++k &lt; l)&#123;</span><br><span class="line">        for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">            if(!b[i])if(f[i][k] != c[k])b[i]=true;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        if(!b[i])ans[f[i][l]-64]=1;</span><br><span class="line">    &#125;</span><br><span class="line">    print();</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T2"><a href="#T2" class="headerlink" title="T2:"></a>T2:</h4><p>自己用暴力做的80分，正解二分，没什么多说的了。</p>
<p>暴力代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define maxn 100003</span><br><span class="line">using namespace std;</span><br><span class="line">int a,b,c,i,j,k;</span><br><span class="line">long long ans;          //此题的大坑点，无数打正解的人都wa在这</span><br><span class="line">int cake1[maxn],cake2[maxn],cake3[maxn];</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d%d&quot;,&amp;a,&amp;b,&amp;c);</span><br><span class="line">    for(i=1;i&lt;=a;i++)cin&gt;&gt;cake1[i];</span><br><span class="line">    for(i=1;i&lt;=b;i++)cin&gt;&gt;cake2[i];</span><br><span class="line">    for(i=1;i&lt;=c;i++)cin&gt;&gt;cake3[i];</span><br><span class="line">    for(i=1;i&lt;=a;i++)&#123;</span><br><span class="line">        for(j=1;j&lt;=b;j++)&#123;</span><br><span class="line">            if(cake1[i]&gt;=cake2[j])continue;</span><br><span class="line">            for(k=1;k&lt;=c;k++)&#123;</span><br><span class="line">                if(cake2[j]&gt;=cake3[k])continue;</span><br><span class="line">                ans+=1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;%d&quot;,ans);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="T3"><a href="#T3" class="headerlink" title="T3:"></a>T3:</h4><p>一道动规题，当初做时以为是DFS，结果爆0了…….</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define maxn 5000</span><br><span class="line">#define inf 0xfffffff</span><br><span class="line">int sc[maxn+5],n,l,r,ans=-inf,f[maxn+5];</span><br><span class="line">int main()&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    for(int i=1;i&lt;=n;i++)&#123;</span><br><span class="line">        cin&gt;&gt;sc[i];</span><br><span class="line">        f[i]=-inf;</span><br><span class="line">    &#125;</span><br><span class="line">    f[1]=sc[1];</span><br><span class="line">    for(int i=2;i&lt;=n;i++)&#123;</span><br><span class="line">        for(int j=l;j&lt;=r;j++)&#123;</span><br><span class="line">            if(i-j &gt; 0)f[i]=max(f[i],f[i-j]);</span><br><span class="line">        &#125;</span><br><span class="line">        if(f[i]!=-inf)f[i]+=sc[i];</span><br><span class="line">        if(i+l&gt;=n)ans=max(ans,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    ﻿
</code></pre>
]]></content>
      <tags>
        <tag>考试</tag>
        <tag>题解</tag>
      </tags>
  </entry>
  <entry>
    <title>Test 2019.5.4 题解</title>
    <url>/2019/05/04/Test%202019.5.4/</url>
    <content><![CDATA[<p>今天下午日常考试，交上去的时候以为稳稳300(满分),一评测190，真香。好吧，那来总结下本次考试。</p>
<span id="more"></span>

<h2 id="题面"><a href="#题面" class="headerlink" title="题面"></a>题面</h2><p>和为给定数 (sum.cpp)  题目传送门： <a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1244">链接</a></p>
<p>插队(que.cpp)  题目传送门： <a href="https://www.cnblogs.com/wangshengjun/p/10698601.html">链接</a></p>
<p>方格取数（弱化版） 题目传送门：<a href="http://ybt.ssoier.cn:8088/problem_show.php?pid=1277">链接</a>      注：现在只要求求一条路径的最大和。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h3 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h3><p>比较简单，用二分查找就可以了，提交，90分。 （啪~啪）</p>
<p>后来发现是数组开的不够大，加大了一些就过了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int n,m,s[100009],i;   //注意这里要开大一点</span><br><span class="line">int ans[1005][3],p;</span><br><span class="line">bool b=true;</span><br><span class="line">int rain(int  x)&#123;      //二分模板</span><br><span class="line">    int  l=1,r=n,mid;</span><br><span class="line">    while(l&lt;=r)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=l+((r-l)&gt;&gt;1);</span><br><span class="line">        if(s[mid]==x)return mid;</span><br><span class="line">        if(s[mid]&lt;x)l=mid+1;</span><br><span class="line">        if(s[mid]&gt;x)r=mid-1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    for(i=1;i&lt;=n;i++)scanf(&quot;%d&quot;,&amp;s[i]);</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;m);</span><br><span class="line">    sort(s+1,s+n+1);</span><br><span class="line">    for(i=1;s[i]&lt;=m/2;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        if(rain(m-s[i]) &amp;&amp; rain(m-s[i])!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            p++;</span><br><span class="line">            ans[p][1]=s[i];</span><br><span class="line">            ans[p][2]=m-s[i];</span><br><span class="line">            b=false;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int minn=9999999,minx;</span><br><span class="line">    if(!b)&#123;</span><br><span class="line">        for(i=1;i&lt;=p;i++)&#123;</span><br><span class="line">            if(ans[i][1]&gt;ans[i][2])swap(ans[i][1],ans[i][2]);</span><br><span class="line">            if(ans[i][1]&lt;minn)&#123;</span><br><span class="line">                minn=ans[i][1];</span><br><span class="line">                minx=i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;%d %d&quot;,ans[minx][1],ans[minx][2]);</span><br><span class="line">    &#125;</span><br><span class="line">    else if(b)printf(&quot;No&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="que-cpp"><a href="#que-cpp" class="headerlink" title="que.cpp"></a>que.cpp</h3><p>这道题目交上去的时候以为是稳100的，可结果是0分啊！！！0分啊！！！</p>
<p>自己看了半天没看出问题来，后来看了半天实在没看懂只能屁颠屁颠跑去问老师，标程是张这样的（落差好大）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;cstdio&gt;</span><br><span class="line">#define maxn 393939</span><br><span class="line">using namespace std;</span><br><span class="line">int n, q, x, y;</span><br><span class="line">int f[maxn], g[maxn], head;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d%d&quot;, &amp;n, &amp;q);</span><br><span class="line">    for(int i = 1; i &lt; n+1; i++)f[i] = i+1, g[i] = i-1;</span><br><span class="line">    head = 1;</span><br><span class="line">    while(q--)&#123;</span><br><span class="line">        scanf(&quot;%d%d&quot;, &amp;x, &amp;y);</span><br><span class="line">        if(x==head)head = f[x];</span><br><span class="line">        f[g[x]] = f[x];</span><br><span class="line">        g[f[x]] = g[x];</span><br><span class="line">        f[x] = f[y];</span><br><span class="line">        g[f[y]] = x;</span><br><span class="line">        f[y] = x;</span><br><span class="line">        g[x] = y;</span><br><span class="line">    &#125;</span><br><span class="line">    int i = head, j = 0;</span><br><span class="line">    while(i!=n+1)&#123;</span><br><span class="line">        printf(&quot;%d &quot;, i);</span><br><span class="line">        i = f[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这道题目的<strong>正解</strong>是双向链表，目前还没有学，等以后学了再来补上…..</p>
<h3 id="box-cpp"><a href="#box-cpp" class="headerlink" title="box.cpp"></a>box.cpp</h3><p>标准的动态规划，比较简单。</p>
<p>每个点的最大值用递推公式得：max(sum[x-1][y],sum[x][y-1])+s[x][y]</p>
<p>那么这道题目的思路就清晰了：把每个点的最大值得出，然后输出就行了；</p>
<p>但据说原题不是张这样的，原题：<a href="https://www.luogu.org/problemnew/show/P1004">链接</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">#include&lt;bits/stdc++.h&gt;</span><br><span class="line">#define l 15</span><br><span class="line">using namespace std;</span><br><span class="line">int x,y,z;</span><br><span class="line">int n,s[l][l],sum[l][l];</span><br><span class="line">int t,i,j;</span><br><span class="line">int rain(int x,int y)&#123;return max(sum[x-1][y],sum[x][y-1])+s[x][y];&#125;</span><br><span class="line">int main()&#123;</span><br><span class="line">    scanf(&quot;%d&quot;,&amp;n);</span><br><span class="line">    while(scanf(&quot;%d %d %d&quot;,&amp;x,&amp;y,&amp;z))&#123;</span><br><span class="line">        if(x==0 &amp;&amp; y==0 &amp;&amp; z==0)break;</span><br><span class="line">        s[x][y] = z;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i=1;i&lt;=n;i++)</span><br><span class="line">        for(j=1;j&lt;=n;j++)</span><br><span class="line">            sum[i][j]=rain(i,j);</span><br><span class="line">    printf(&quot;%d\n&quot;,sum[n][n]);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<pre><code>    ﻿
</code></pre>
]]></content>
      <tags>
        <tag>考试</tag>
        <tag>题解</tag>
      </tags>
  </entry>
</search>
